# MVCC

MVCC，全称Multi-Version Concurrency Control，即多版本并发控制。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。

MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，***做到即使有读写冲突时，也能做到不加锁，非阻塞并发读***

## MVCC解决的问题

数据库并发场景有三种，分别为：

- 读-读：不存在任何问题，也不需要并发控制
- 读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读
- 写-写：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失

版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 所以MVCC可以为数据库解决以下问题

- 在并发读写数据库时，可以做到在快照读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能 
- 解决脏读，幻读，不可重复读等事务隔离问题

但是不能解决更新丢失问题。

MVCC解决读写冲突，锁（乐观锁|悲观锁）解决写写冲突

## 当前读，快照读和MVCC的关系

MVCC就是为了实现读-写冲突不加锁，而这个读指的就是快照读, 而非当前读，当前读实际上是一种加锁的操作，是悲观锁的实现

准确的说，MVCC多版本并发控制指的是 ***维持一个数据的多个版本，使得读写操作没有冲突*** 这么一个概念。仅仅是一个理想概念 而在MySQL中，实现这么一个MVCC理想概念，我们就需要MySQL提供具体的功能去实现它，而 ***快照读*** 就是MySQL为我们实现MVCC理想模型的其中一个具体非阻塞读功能。而相对而言，***当前读*** 就是悲观锁的具体功能实现 要说的再细致一些，快照读本身也是一个抽象概念，再深入研究。MVCC模型在MySQL中的具体实现则是由 3个隐式字段，undo日志 ，Read View 等去完成的，具体可以看下面的MVCC实现原理

### 当前读current read

读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对*读取的记录进行加锁*。事务更新数据的时候，只能用当前读。当前读典型的sql语句：

- select lock in share mode(共享锁)
- select for update
- update
- insert
- delete(排他锁)

### 快照读

像不加锁的select操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即MVCC,可以认为MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本

## MVCC的实现原理

实现原理主要是依赖记录中的 3个隐式字段，undo日志 ，Read View 来实现的。所以我们先来看看这个三个point的概念

### 隐式字段
<!-- todo -->
### undo日志
<!-- todo -->
### Read View

consistent read view就是在某一时刻给事务系统trx_sys打snapshot（快照），把当时trx_sys状态（包括活跃读写事务数组）记下来，之后的所有读操作根据其事务ID（即trx_id）与snapshot中的trx_sys的状态作比较，以此判断read view对于*事务的可见性*。

#### 可见性

数据版本的可见性规则，就是基于数据的 row trx_id 和事务系统状态对比结果得到的。

![](../assets/images/baa9fb06-596a-4b47-b798-53ac22d1bb1e.png)

对于 ***当前事务的启动瞬间*** 来说，一个数据版本的 row trx_id，有以下几种可能：

1. 如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；
2. 如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；
3. 如果落在黄色部分，那就包括两种情况
    a. 若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见；
    b. 若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。

注意：

> 黄色块只是大于低水位小于高水位，但是黄色块中也有已提交的事务，并不是全都是未提交事务，而黄色块里的事务提交没提交，正是要通过活跃事务数组判断的。黄色块中的事务，且在活跃事务数组中的部分，是生成快照时还未提交的事务；黄色块中的事务，且不在活跃事务数组中的部分，是生成快照时已经提交了的事务。
> 事务ID高于高水位（当前系统里已经创建过的事务ID的最大值）的一定是建立快照时还没创建的，那么对当前事务不可见；小于高水位的且在活跃事务数组中的，说明建立快照时它还在活跃，一定是还没提交的，那么对当前事务不可见；小于高水位且不在活跃事务数组中的，说明建立了快照时它已经提交了，那么对当前事务可见。
>
> 落在黄色区域意味着是事务ID在低水位和高水位这个范围里面，而真正是是否可见，看黄色区域是否有这个值。如果黄色区域没有这个事务ID，则可见，如果有，则不可见。
> 在这个范围里面并不意味这这个范围里有这个值，比如[1,2,3,5]，4在这个数组1-5的范围里，却没在这个数组里面。

#### 示例

> 在实现上， InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务 ID。“活跃”指的就是，启动了但还没提交。数组里面事务 ID 的最小值记为低水位，当前系统里面已经创建过的事务 ID 的最大值加 1 记为高水位。这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。而数据版本的可见性规则，就是基于数据的 row trx_id 和这个一致性视图的对比结果得到的。

假如当前系统已经创建过的事务 ID的最大值是6，那么系统过去创建过的事务ID有1，2，3，4，5，6。假如现在是事务4开启了一致性视图，在开启的瞬间，得到“活跃”事务ID数组[3，4，5]。然后事务4算得，低水位3，高水位7（当前最大事务ID 6+1）。然后事务4读取数据的row trx_id，判断如下：

1. row trx_id 为1，2时，由于小于低水位3，所以1，2在绿色区域，对事务4可见。
2. row trx_id 为7，8，9或更大时，由于都大于或等于高水位7，所以都在红色区域，对事务4不可见。且无论他们是否已提交，不用管，一律不可见。
3. row trx_id 为6，大于低水位3，小于高水位7，也就是在所谓的黄色区域，但是6又不在活跃数组[3，4，5]中，那么推断6只能在绿色区域中。就是说6是在事务4一致性视图开启前，已提交的事务。（一致性视图不一定是事务启动的时候就开启的）

#### 实现：保留trx_sys事务系统状态

在Repeatable Read级别下，一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见。对于事务来说，需要根据版本号以及Undo Logs计算出他需要的版本对应的数据

一个事务只需要在启动时记录trx_sys状态，之后的所有读操作根据其事务ID（即trx_id）与snapshot中的trx_sys的状态作比较，以此判断read view对于事务的可见性。

- low_limit_id：high water mark，大于等于view->low_limit_id的事务对于view都是不可见的
- up_limit_id：low water mark，小于view->up_limit_id的事务对于view一定是可见的
- low_limit_no：trx_no小于view->low_limit_no的undo log对于view是可以purge的
- rw_trx_ids：读写事务数组

视图数组和高水位，就组成了当前事务的一致性视图（read-view）

> Innodb 要保证这个规则：事务启动以前所有还没提交的事务，它都不可见。但是只存一个已经提交事务的最大值是不够的。 因为存在一个问题，那些比最大值小的事务，之后也可能更新（就是你说的98这个事务）所以事务启动的时候还要保存“现在正在执行的所有事物ID列表”，如果一个row trx_id在这列表中，也要不可见。

#### RR和RC隔离级别的区别

RC（Read Committed）和RR（Repeatable Read）隔离级别是利用consistent read view（一致读视图）方式支持的

##### Gap锁

<!-- todo -->

##### 创建read view时机

RC隔离级别是在语句开始时刻创建read view的。

RR隔离级别是在事务开始时刻，确切地说是第一个读操作创建read view的；

- begin/start transaction

如果事务 A 是以 begin/start transaction 的方式启动的，那么此时，read-view 还没有创建，事务 A 中第一条读操作执行的时候，read-view 才会创建；此时，离 begin/start transaction 的执行已经过去一段时间，在这段时间中，会有新的事务被创建，这些新事务的 trx_id 都会比事务 A 的 trx_id 大；那么在这个数组中，事务 A 的 trx_id 就未必是数据中最后一个元素；这意味着，高水位线和事务 A 的 trx_id 之间有别的 trx_id。

- start transaction with consistent snapshot

如果事务 A 是以 start transaction with consistent snapshot 的方式开启事务，那么 read-view 在这一瞬间创建，事务 A 的 trx_id 就是数组中最后一个元素，高水位线就比事务 A 的 trx_id 大 1。

## 参考

- [阿里面试问MVCC,原来是这么回答的](https://juejin.im/post/6847902218729816071)
- [MySQL · 源码分析 · InnoDB的read view，回滚段和purge过程简介](http://mysql.taobao.org/monthly/2018/03/01/)
- MySQL实战45讲
