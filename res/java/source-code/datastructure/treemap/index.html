<!doctype html><html lang=zh-cn>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge,chrome=1">
<title> - Even - A super concise theme for Hugo</title>
<meta name=renderer content="webkit">
<meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1">
<meta http-equiv=cache-control content="no-transform">
<meta http-equiv=cache-control content="no-siteapp">
<meta name=theme-color content="#f8f5ec">
<meta name=msapplication-navbutton-color content="#f8f5ec">
<meta name=apple-mobile-web-app-capable content="yes">
<meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec">
<meta name=author content="navyd"><meta name=description content="TreeMap 基于红黑树（Red-Black tree）的 NavigableMap 实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构"><meta name=keywords content="Hugo,blog,navyd">
<meta name=generator content="Hugo 0.87.0 with theme even">
<link rel=canonical href=https://navyd.github.io/res/java/source-code/datastructure/treemap/>
<link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png>
<link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png>
<link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png>
<link rel=manifest href=/manifest.json>
<link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5>
<link href=/sass/main.min.a659bb31b17a54f7792e1bc783fc75b31118e6a175b42337b03fae0b1a3ef2b5.css rel=stylesheet>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous>
<meta property="og:title" content>
<meta property="og:description" content="TreeMap 基于红黑树（Red-Black tree）的 NavigableMap 实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构">
<meta property="og:type" content="article">
<meta property="og:url" content="https://navyd.github.io/res/java/source-code/datastructure/treemap/"><meta property="article:section" content="res">
<meta itemprop=name content>
<meta itemprop=description content="TreeMap 基于红黑树（Red-Black tree）的 NavigableMap 实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构">
<meta itemprop=wordCount content="3462">
<meta itemprop=keywords content><meta name=twitter:card content="summary">
<meta name=twitter:title content>
<meta name=twitter:description content="TreeMap 基于红黑树（Red-Black tree）的 NavigableMap 实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]-->
</head>
<body>
<div id=mobile-navbar class=mobile-navbar>
<div class=mobile-header-logo>
<a href=/ class=logo>navyd的个人博客</a>
</div>
<div class=mobile-navbar-icon>
<span></span>
<span></span>
<span></span>
</div>
</div>
<nav id=mobile-menu class="mobile-menu slideout-menu">
<ul class=mobile-menu-list>
<a href=/>
<li class=mobile-menu-item>Home</li>
</a><a href=/post/>
<li class=mobile-menu-item>Archives</li>
</a><a href=/tags/>
<li class=mobile-menu-item>Tags</li>
</a><a href=/categories/>
<li class=mobile-menu-item>Categories</li>
</a>
</ul>
</nav>
<div class=container id=mobile-panel>
<header id=header class=header>
<div class=logo-wrapper>
<a href=/ class=logo>navyd的个人博客</a>
</div>
<nav class=site-navbar>
<ul id=menu class=menu>
<li class=menu-item>
<a class=menu-item-link href=/>Home</a>
</li><li class=menu-item>
<a class=menu-item-link href=/post/>Archives</a>
</li><li class=menu-item>
<a class=menu-item-link href=/tags/>Tags</a>
</li><li class=menu-item>
<a class=menu-item-link href=/categories/>Categories</a>
</li>
</ul>
</nav>
</header>
<main id=main class=main>
<div class=content-wrapper>
<div id=content class=content>
<article class=post>
<div class=post-content>
<h1 id=treemap>TreeMap</h1>
<p>基于红黑树（Red-Black tree）的 NavigableMap 实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。此实现为 containsKey、get、put 和 remove 操作提供受保证的 log(n) 时间开销。
这些算法是 Cormen、Leiserson 和 Rivest 的 Introduction to Algorithms 中的算法的改编。</p>
<p>关于TreeMap中红黑树：TreeMap红黑树分析</p>
<p>TreeMap的继承实现结构</p>
<pre><code>public class TreeMap&lt;K,V&gt;
extends AbstractMap&lt;K,V&gt;
implements NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable
</code></pre>
<p>TreeMap&lt;K,V>：TreeMap是以key-value形式存储数据的。</p>
<p>extends AbstractMap&lt;K,V>：继承了AbstractMap，实现Map接口时需要实现的工作量大大减少了。</p>
<p>implements NavigableMap：实现了NavigableMap，可以返回特定条件最近匹配的导航方法。方法 lowerEntry、floorEntry、ceilingEntry 和 higherEntry 分别返回与小于、小于等于、大于等于、
大于给定键的键关联的 Map.Entry 对象，如果不存在这样的键，则返回 null。</p>
<p>implements Cloneable：表明其可以调用clone()方法来返回实例的field-for-field拷贝。</p>
<p>implements Serializable：表明该类是可以序列化的。</p>
<p><strong>主要字段：</strong></p>
<pre><code>/**
 * treeMap的排序规则，如果为null，则根据键的自然顺序进行排序
 */
private final Comparator&lt;? super K&gt; comparator;

/**
 * 红黑数的根节点
 */
private transient Entry&lt;K,V&gt; root;

/**
 * 红黑树节点的个数
 */
private transient int size = 0;

/**
 * treeMap的结构性修改次数。实现fast-fail机制的关键。
 */
private transient int modCount = 0;

/**
 * 视图只有在第一次请求时创建并只创建一个
 */
private transient EntrySet entrySet;
private transient KeySet&lt;K&gt; navigableKeySet;
private transient NavigableMap&lt;K,V&gt; descendingMap;
</code></pre>
<p><strong>构造方法：</strong></p>
<ul>
<li>TreeMap()：使用key的自然排序来构造一个空的treeMap。</li>
<li>TreeMap(Comparator&lt;? super K> comparator)：使用给定的比较器来构造一个空的treeMap。</li>
<li>TreeMap(Map&lt;? extends K, ? extends V> m)：使用key的自然排序来构造一个treeMap，treeMap包含给定map中所有的键值对。
<code>public TreeMap(Map&lt;? extends K, ? extends V> m) {
comparator = null;
putAll(m);
}</code></li>
<li>TreeMap(SortedMap&lt;K, ? extends V> m)：使用指定的sortedMap来构造treeMap。treeMap中含有sortedMap中所有的键值对，键值对顺序和sortedMap中相同。使用一个有序的map构造新的treemap。这个方法需要线性时间</li>
</ul>
<p><strong>主要方法：</strong></p>
<p>get方法：</p>
<pre><code> /**
 * 通用二叉树的查找算法。提供log2(n)的复杂度
 * @param key
 * @return
 */
final Entry&lt;K,V&gt; getEntry(Object key) {
    // Offload comparator-based version for sake of performance
	// 直接使用指定的比较器查找
    if (comparator != null)
        return getEntryUsingComparator(key);// 与当前方法类似，只是使用compare(o1,o2)比较
    // 不允许null
    if (key == null)
        throw new NullPointerException();
    @SuppressWarnings(&quot;unchecked&quot;)
    Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;
    Entry&lt;K,V&gt; p = root;
    // 查找
    while (p != null) {
        int cmp = k.compareTo(p.key);
        // key小于当前节点取左节点比较
        if (cmp &lt; 0)
            p = p.left;
        // key大于当前节点取右节点比较
        else if (cmp &gt; 0)
            p = p.right;
        // 找到
        else
            return p;
    }
    // 没有找到
    return null;
}

 /**
 * 返回大于等于key的最小键。如果不存在就返回null。
 * 算法：
 * 1.如果key &lt; 当前节点p，寻找左子树，若左子树不存在，p就是最小大于key的
 * 2.如果key &gt; 当前节点p，寻找右子树，若右子树不存在，需要向上回溯第一个大于key的键
 * 即key &lt; 节点p，使用左链接(一个大于等于key的键的左子树中不存在更小的大于等于key的键)
 * @param key
 * @return
 */
final Entry&lt;K,V&gt; getCeilingEntry(K key) {
    Entry&lt;K,V&gt; p = root;
    while (p != null) {
        // 静态方法，比较器comparator为空就是用默认的比较
        int cmp = compare(key, p.key);
        // key比当前节点小
        if (cmp &lt; 0) {
            // 当前节点存在更小的子节点
            if (p.left != null)
                p = p.left;
            // 没有更小的子节点，当前节点就是树中最小大于key的节点
            else
                return p;
        } 
        // key比当前节点大
        else if (cmp &gt; 0) {
            // 当前节点存在更大的子节点
            if (p.right != null) {
                p = p.right;
            }
            // 当前节点没有更大的节点能大于key，即子树中不存在大于key的键。只能向上回溯第一个使用左链接比较的节点
            // 即当一个节点p大于key时，仍然在左子树中寻找小于p大于key的键，那么第一个左链接节点必定是最小大于key的
            else {
                Entry&lt;K,V&gt; parent = p.parent;
                Entry&lt;K,V&gt; ch = p;
                // parent.left连接时退出循环或不存在大于等于key的键
                while (parent != null &amp;&amp; ch == parent.right) {
                    ch = parent;
                    parent = parent.parent;
                }
                return parent;
            }
        } 
        // 找到key相等节点p
        else
            return p;
    }
    return null;
}

 /**
 * 取小于等于key的最大键。遇到第一个key.compareTo(p) &gt; 0的就会到右子树中取最小值
 * 算法：
 * 1.如果key &lt; 当前节点p，若p的左子树存在，就查找左子树，如果不存在，就回溯找第一个小于key的键
 * 即k &gt; 节点p，使用右连接的父节点(原理是当一个节点小于key，就会查找右子树是否有大一点的节点小于key)
 * 2.如果key &gt; 当前节点p，寻找右子树，若右子树不存在就返回p最小大于等于key的
 * @param key
 * @return
 */
final Entry&lt;K,V&gt; getFloorEntry(K key) {
    Entry&lt;K,V&gt; p = root;
    while (p != null) {
        int cmp = compare(key, p.key);
        // key比当前节点大
        if (cmp &gt; 0) {
            if (p.right != null)
                p = p.right;
            // 找不到比key更大的键，就返回当前键是小于key的最大键
            else
                return p;
        } 
        // key比当前节点小
        else if (cmp &lt; 0) {
            if (p.left != null) {
                p = p.left;
            } 
            // 找不到
            else {
                // 如果左子树中不存在跟接近key的节点就返回第一个右链接的父节点
                Entry&lt;K,V&gt; parent = p.parent;
                Entry&lt;K,V&gt; ch = p;
                // 当parent使用右链接时退出循环或不存在小于等于key的键
                while (parent != null &amp;&amp; ch == parent.left) {
                    ch = parent;
                    parent = parent.parent;
                }
                return parent;
            }
        } 
        // 相等
        else
            return p;

    }
    return null;
}
</code></pre>
<p>put方法：</p>
<pre><code> /**
 * 在map中关联指定的键值对。不允许插入null。只对插入操作进行红黑树修复。提供log(n)复杂度
 */
public V put(K key, V value) {
    Entry&lt;K,V&gt; t = root;
    // 根节点为null就直接插入新键
    if (t == null) {
        compare(key, key); // type (and possibly null) check

        root = new Entry&lt;&gt;(key, value, null);
        size = 1;
        modCount++;
        return null;
    }
    // 引用放在循环外。是否感觉可以改善自己的代码啦啦？？？等到知道具体机制可能就不会这样想了。手动滑稽
    int cmp;
    Entry&lt;K,V&gt; parent;
    // split comparator and comparable paths
    Comparator&lt;? super K&gt; cpr = comparator;
    // 使用比较器查找到key进行替换操作
    if (cpr != null) {
        do {
            parent = t;
            cmp = cpr.compare(key, t.key);
            if (cmp &lt; 0)
                t = t.left;
            else if (cmp &gt; 0)
                t = t.right;
            // 相等就直接替换值
            else
                return t.setValue(value);
        } while (t != null);
    }
    // 使用默认的顺序查找到key进行替换操作
    else {
        // 不允许为null
        if (key == null)
            throw new NullPointerException();
        @SuppressWarnings(&quot;unchecked&quot;)
            Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;
        do {
            parent = t;
            cmp = k.compareTo(t.key);
            if (cmp &lt; 0)
                t = t.left;
            else if (cmp &gt; 0)
                t = t.right;
            else
                return t.setValue(value);
        } while (t != null);
    }
    // 将新节点插入到父节点
    Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent);
    // 判断父节点应用哪个连接新节点
    if (cmp &lt; 0)
        parent.left = e;
    else
        parent.right = e;
    // 修复操作
    fixAfterInsertion(e);
    size++;
    modCount++;
    return null;
}

/**
 * 将指定映射中的所有映射关系复制到此映射中。如果已经存在的映射会被替换新的值
 * 对于空treemap使用putAll提供线性时间。好于非空treemap的n*logn
 * @author Navy D
 */
public void putAll(Map&lt;? extends K, ? extends V&gt; map) {
    int mapSize = map.size();
    // treemap是空的  参数map是sortedMap
    if (size==0 &amp;&amp; mapSize!=0 &amp;&amp; map instanceof SortedMap) {
        Comparator&lt;?&gt; c = ((SortedMap&lt;?,?&gt;)map).comparator();
        // 比较器一样为null或同一个对象
        if (c == comparator || (c != null &amp;&amp; c.equals(comparator))) {
            ++modCount;
            try {
                // 使用迭代器通过key构建排序数据，需要线性时间 这个方法暂时没用到就不看了，用到再更新吧
                buildFromSorted(mapSize, map.entrySet().iterator(),
                                null, null);
            } catch (java.io.IOException cannotHappen) {
            } catch (ClassNotFoundException cannotHappen) {
            }
            return;
        }
    }
    // abstractMap.putAll方法采用for调用put方法
    super.putAll(map);
}
</code></pre>
<p>delete方法：</p>
<pre><code> /**
 * 在map中删除指定的键和关联的值
 */
public V remove(Object key) {
	// 查找
    Entry&lt;K,V&gt; p = getEntry(key);
    if (p == null)
        return null;

    V oldValue = p.value;
    // 删除键值对
    deleteEntry(p);
    return oldValue;
}

 /**
 * 删除节点p且平衡树
 * 对于有两个子节点的删除节点p，使用右子树的最小节点替换，
 * 然后根据这个最小节点是叶子结点就先修复再删除，若有一个右子树就使用右子树中节点与父节点连接
 * 对于有一个子节点的删除节点p，使用删除节点的子节点与父节点连接
 * 对于没右子节点就修复后再删除
 * @param p
 */
private void deleteEntry(Entry&lt;K,V&gt; p) {
    modCount++;
    size--;
    // If strictly internal, copy successor's element to p and then make p
    // point to successor.
    // 待删除结点有两个孩子用中序后继覆盖删除节点
    if (p.left != null &amp;&amp; p.right != null) {
        // 返回p的右子树中的最小节点
        Entry&lt;K,V&gt; s = successor(p);
        // 将后继的键值覆盖删除点p的键值  没有更换颜色
        p.key = s.key;
        p.value = s.value;
        // 将p引用为后继节点 注意不是覆盖到删除节点 删除点p已经被替换为后继
        p = s;
    } // p has 2 children

    // Start fixup at replacement node, if it exists.
    // 如果删除节点只有一个孩子就返回这个孩子。注意如果进入上一个if，返回的p如果是叶节点，即replacement=null
    // p如果不是叶节点，只会存在右子节点
    Entry&lt;K,V&gt; replacement = (p.left != null ? p.left : p.right);
    // 删除节点存在一个子节点(左或右)，父节点链接删除节点的子节点
    if (replacement != null) {
        // Link replacement to parent
        // 连接p的父节点与替换节点  删除p
        replacement.parent = p.parent;
        if (p.parent == null)
            root = replacement;
        // 替换父节点的左链接
        else if (p == p.parent.left)
            p.parent.left  = replacement;
        // 替换右链接
        else
            p.parent.right = replacement;

        // Null out links so they are OK to use by fixAfterDeletion.
        p.left = p.right = p.parent = null;

        // Fix replacement
        // 只有删除点是BLACK的时候，才会触发删除修复，因为删除RED节点不会破坏红黑树的任何约束，而删除BLACK节点会导致有不同个数的黑色节点
        if (p.color == BLACK)
            fixAfterDeletion(replacement);
    }
    // 只有root一个节点
    else if (p.parent == null) { // return if we are the only node.
        root = null;
    }
    // 没有孩子节点 p是叶子结点
    else { //  No children. Use self as phantom replacement and unlink.
        if (p.color == BLACK)
            fixAfterDeletion(p);
        // 将连接删除
        if (p.parent != null) {
            if (p == p.parent.left)
                p.parent.left = null;
            else if (p == p.parent.right)
                p.parent.right = null;
            p.parent = null;
        }
    }
}
</code></pre>
<p>iterator方法：初步看了一下源码，类有点多，等到需要时再更新吧</p>
<hr>
<p>first_edited_20171016</p>
</div>
</article>
</div>
</div>
</main>
<footer id=footer class=footer>
<div class=social-links>
<a href=https://github.com/NavyD/navyd.github.io class="iconfont icon-github" title=github></a>
<a href=https://navyd.github.io/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a>
</div>
<div class=copyright>
<span class=power-by>
由 <a class=hexo-link href=https://gohugo.io>Hugo</a> 强力驱动
</span>
<span class=division>|</span>
<span class=theme-info>
主题 -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a>
</span>
<span class=copyright-year>
&copy;
2021<span class=heart><i class="iconfont icon-heart"></i></span><span>navyd</span>
</span>
</div>
</footer>
<div class=back-to-top id=back-to-top>
<i class="iconfont icon-up"></i>
</div>
</div>
<script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/timeago.js@3.0.2/dist/timeago.min.js integrity="sha256-jwCP0NAdCBloaIWTWHmW4i3snUNMHUNO+jr9rYd2iOI=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/timeago.js@3.0.2/dist/timeago.locales.min.js integrity="sha256-ZwofwC1Lf/faQCzN7nZtfijVV6hSwxjQMwXL4gn9qU8=" crossorigin=anonymous></script>
<script>var languageCode="en".replace(/-/g,'_').replace(/_(.*)/,function(b,a){return b.replace(a,a.toUpperCase())});timeago().render(document.querySelectorAll('.timeago'),languageCode),timeago.cancel()</script>
<script type=text/javascript src=/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js></script>
</body>
</html>