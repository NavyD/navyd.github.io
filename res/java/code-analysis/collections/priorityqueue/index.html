<!doctype html><html lang=zh-cn>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge,chrome=1">
<title> - Even - A super concise theme for Hugo</title>
<meta name=renderer content="webkit">
<meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1">
<meta http-equiv=cache-control content="no-transform">
<meta http-equiv=cache-control content="no-siteapp">
<meta name=theme-color content="#f8f5ec">
<meta name=msapplication-navbutton-color content="#f8f5ec">
<meta name=apple-mobile-web-app-capable content="yes">
<meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec">
<meta name=author content="navyd"><meta name=description content="PriorityQueue 一个基于优先级堆的无界优先级队列。 二叉堆 二叉堆(The binary heap)数据结构能够有效的支持基本的优先队列操作。key存储在一个数组中，其中每"><meta name=keywords content="Hugo,blog,navyd">
<meta name=generator content="Hugo 0.87.0 with theme even">
<link rel=canonical href=https://navyd.github.io/res/java/code-analysis/collections/priorityqueue/>
<link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png>
<link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png>
<link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png>
<link rel=manifest href=/manifest.json>
<link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5>
<script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<link href=/sass/main.min.a659bb31b17a54f7792e1bc783fc75b31118e6a175b42337b03fae0b1a3ef2b5.css rel=stylesheet>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous>
<meta property="og:title" content>
<meta property="og:description" content="PriorityQueue 一个基于优先级堆的无界优先级队列。 二叉堆 二叉堆(The binary heap)数据结构能够有效的支持基本的优先队列操作。key存储在一个数组中，其中每">
<meta property="og:type" content="article">
<meta property="og:url" content="https://navyd.github.io/res/java/code-analysis/collections/priorityqueue/"><meta property="article:section" content="res">
<meta itemprop=name content>
<meta itemprop=description content="PriorityQueue 一个基于优先级堆的无界优先级队列。 二叉堆 二叉堆(The binary heap)数据结构能够有效的支持基本的优先队列操作。key存储在一个数组中，其中每">
<meta itemprop=wordCount content="6173">
<meta itemprop=keywords content><meta name=twitter:card content="summary">
<meta name=twitter:title content>
<meta name=twitter:description content="PriorityQueue 一个基于优先级堆的无界优先级队列。 二叉堆 二叉堆(The binary heap)数据结构能够有效的支持基本的优先队列操作。key存储在一个数组中，其中每"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]-->
</head>
<body>
<div id=mobile-navbar class=mobile-navbar>
<div class=mobile-header-logo>
<a href=/ class=logo>navyd的个人博客</a>
</div>
<div class=mobile-navbar-icon>
<span></span>
<span></span>
<span></span>
</div>
</div>
<nav id=mobile-menu class="mobile-menu slideout-menu">
<ul class=mobile-menu-list>
<a href=/>
<li class=mobile-menu-item>Home</li>
</a><a href=/post/>
<li class=mobile-menu-item>Archives</li>
</a><a href=/tags/>
<li class=mobile-menu-item>Tags</li>
</a><a href=/categories/>
<li class=mobile-menu-item>Categories</li>
</a>
</ul>
</nav>
<div class=container id=mobile-panel>
<header id=header class=header>
<div class=logo-wrapper>
<a href=/ class=logo>navyd的个人博客</a>
</div>
<nav class=site-navbar>
<ul id=menu class=menu>
<li class=menu-item>
<a class=menu-item-link href=/>Home</a>
</li><li class=menu-item>
<a class=menu-item-link href=/post/>Archives</a>
</li><li class=menu-item>
<a class=menu-item-link href=/tags/>Tags</a>
</li><li class=menu-item>
<a class=menu-item-link href=/categories/>Categories</a>
</li>
</ul>
</nav>
</header>
<main id=main class=main>
<div class=content-wrapper>
<div id=content class=content>
<article class=post>
<div class=post-content>
<h1 id=priorityqueue>PriorityQueue</h1>
<p>一个基于优先级堆的无界优先级队列。</p>
<h2 id=二叉堆>二叉堆</h2>
<p>二叉堆(The binary heap)数据结构能够有效的支持基本的优先队列操作。key存储在一个数组中，其中每个key大于(或等于)指定的两个位置及以上的key</p>
<p>如果key节点比两个key子节点（如果有）大或等于表示这个二叉树是堆有序的。（子节点间无序）</p>
<p><img src=../../../assets/images/5a6aad91-3f5b-4953-b2b2-2712973198d0.png alt></p>
<h3 id=位置>位置</h3>
<p>二叉堆使用完全二叉树在数组中实现，堆中节点的位置可以用数组下标很方便的表示：</p>
<h4 id=数组下标1开始>数组下标1开始</h4>
<p><img src=../../../assets/images/32fbdbf9-4559-45e5-8f87-ff07ffce6620.png alt></p>
<p>一个节点的父节点：<code>k/2</code> 向下取整</p>
<p>一个节点的两个子节点：左子节点<code>2*k</code> 右子节点<code>2*k+1</code>。</p>
<h4 id=数组下标0开始>数组下标0开始</h4>
<p>父节点：<code>(k-1)/2</code> 向下取整</p>
<p>左子节点：<code>2*k+1</code></p>
<p>右子节点：<code>2*(k+1)</code> 即 <code>(2*k+1)+1</code></p>
<p>最后一个父节点（只有存在子节点）：<code>(size/2)-1</code></p>
<p><em><strong>PriorityQueue为下标0开始</strong></em></p>
<h3 id=有序化>有序化</h3>
<h4 id=上浮siftup>上浮（siftUp）</h4>
<p>当一个key被添加到有序的二叉堆时，此时会破坏堆的有序性，需要交换key使堆有序。假设使用最大优先队列即父节点大于或等于子节点</p>
<p><img src=../../../assets/images/5fd5dedd-8459-414c-ab9e-9914ecdf4923.png alt></p>
<p>过程很简单，即比较key与父节点p位置为<code>(k-1)/2</code>的大小：（针对最大优先队列，如果是最小优先，颠倒符号即可）</p>
<ul>
<li>如果key>p就交换两者的位置并与新的父节点继续比较</li>
<li>如果key&lt;=p排序完成</li>
</ul>
<h5 id=插入add>插入add</h5>
<ul>
<li>优先队列不允许插入null元素</li>
<li>优先队列先执行扩容操作才将元素插入新数组。即在扩容前堆数组可能装满元素</li>
<li>插入新元素后需要在堆向上<code>siftUp</code>使堆有序</li>
</ul>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>offer</span><span class=o>(</span><span class=n>E</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
    <span class=c1>// 不允许插入null元素
</span><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>e</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
        <span class=k>throw</span> <span class=k>new</span> <span class=n>NullPointerException</span><span class=o>();</span>
    <span class=n>modCount</span><span class=o>++;</span>
    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>size</span><span class=o>;</span>
    <span class=c1>// 如果堆数组已满  执行扩容操作
</span><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>i</span> <span class=o>&gt;=</span> <span class=n>queue</span><span class=o>.</span><span class=na>length</span><span class=o>)</span>
        <span class=c1>// i + 1用于判断是否溢出， 对于一般的扩容容量没有影响，当容量达到int和vm的限制时才有影响
</span><span class=c1></span>        <span class=n>grow</span><span class=o>(</span><span class=n>i</span> <span class=o>+</span> <span class=n>1</span><span class=o>);</span>
    <span class=n>size</span> <span class=o>=</span> <span class=n>i</span> <span class=o>+</span> <span class=n>1</span><span class=o>;</span>
    <span class=c1>// 插入第一个元素
</span><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>i</span> <span class=o>==</span> <span class=n>0</span><span class=o>)</span>
        <span class=n>queue</span><span class=o>[</span><span class=n>0</span><span class=o>]</span> <span class=o>=</span> <span class=n>e</span><span class=o>;</span>
    <span class=c1>// 插入数组已有元素最后然后向上有序，i为最新位置
</span><span class=c1></span>    <span class=k>else</span>
        <span class=n>siftUp</span><span class=o>(</span><span class=n>i</span><span class=o>,</span> <span class=n>e</span><span class=o>);</span>
    <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
<span class=o>}</span>
</code></pre></td></tr></table>
</div>
</div><h5 id=siftup源码>siftUp源码</h5>
<p>下面是PriorityQueue的源码，注意是使用最小优先队列，如果时最大优先队列，只需要更该为<code>if (key.compareTo((E) e) &lt;= 0)</code></p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=c1>// 使用指定位置k的节点x向上使堆有序
</span><span class=c1></span><span class=nd>@SuppressWarnings</span><span class=o>(</span><span class=s>&#34;unchecked&#34;</span><span class=o>)</span>
<span class=kd>private</span> <span class=kt>void</span> <span class=nf>siftUpComparable</span><span class=o>(</span><span class=kt>int</span> <span class=n>k</span><span class=o>,</span> <span class=n>E</span> <span class=n>x</span><span class=o>)</span> <span class=o>{</span>
    <span class=n>Comparable</span><span class=o>&lt;?</span> <span class=kd>super</span> <span class=n>E</span><span class=o>&gt;</span> <span class=n>key</span> <span class=o>=</span> <span class=o>(</span><span class=n>Comparable</span><span class=o>&lt;?</span> <span class=kd>super</span> <span class=n>E</span><span class=o>&gt;)</span> <span class=n>x</span><span class=o>;</span>
    <span class=c1>// 找到key在堆中的位置  当key的位置k是根节点位置0时终止
</span><span class=c1></span>    <span class=k>while</span> <span class=o>(</span><span class=n>k</span> <span class=o>&gt;</span> <span class=n>0</span><span class=o>)</span> <span class=o>{</span>
        <span class=c1>// k位置的父节点位置
</span><span class=c1></span>        <span class=kt>int</span> <span class=n>parent</span> <span class=o>=</span> <span class=o>(</span><span class=n>k</span> <span class=o>-</span> <span class=n>1</span><span class=o>)</span> <span class=o>&gt;&gt;&gt;</span> <span class=n>1</span><span class=o>;</span>
        <span class=n>Object</span> <span class=n>e</span> <span class=o>=</span> <span class=n>queue</span><span class=o>[</span><span class=n>parent</span><span class=o>];</span>
        <span class=c1>// 如果key比父节点大或相等时 此时堆有序，不用交换了
</span><span class=c1></span>        <span class=k>if</span> <span class=o>(</span><span class=n>key</span><span class=o>.</span><span class=na>compareTo</span><span class=o>((</span><span class=n>E</span><span class=o>)</span> <span class=n>e</span><span class=o>)</span> <span class=o>&gt;=</span> <span class=n>0</span><span class=o>)</span>
            <span class=k>break</span><span class=o>;</span>
        <span class=c1>// 将父节点移动到key的位置  交换key与父节点位置
</span><span class=c1></span>        <span class=n>queue</span><span class=o>[</span><span class=n>k</span><span class=o>]</span> <span class=o>=</span> <span class=n>e</span><span class=o>;</span>
        <span class=c1>// key位置变为父节点位置
</span><span class=c1></span>        <span class=n>k</span> <span class=o>=</span> <span class=n>parent</span><span class=o>;</span>
    <span class=o>}</span>
    <span class=c1>// 找到key在堆中的位置
</span><span class=c1></span>    <span class=n>queue</span><span class=o>[</span><span class=n>k</span><span class=o>]</span> <span class=o>=</span> <span class=n>key</span><span class=o>;</span>
<span class=o>}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id=下沉siftdown>下沉（siftDown）</h4>
<p>在堆中移除后，与二叉树的删除使用左右子树的最值子节点替换类似，对移除位置使用堆数组最后位置元素替换到移除位置上，然后重新平衡二叉堆。</p>
<p>假设使用最大优先队列即父节点大于或等于子节点</p>
<p>当数组最后一个元素被替换到删除位置时，这个叶子节点元素key必定小于删除位置的父节点p，所以需要与较大的子节点child比较</p>
<p><img src=../../../assets/images/6542b390-b72e-459a-af2f-afaad81b52f9.png alt></p>
<ul>
<li>如果节点key &lt; 较大的子节点child，交换key与child的位置，并继续与新的较大子节点比较</li>
<li>如果节点key >= 较大的子节点child，完成当前堆有序</li>
<li>如果节点key交换到了叶子节点<code>k&lt;half</code>即堆中第一个叶子节点为<code>half=(size/2)</code>（数组下标从0开始 1也一样），此时不再需要向下比较non-leaf为<code>(size/2) - 1</code></li>
</ul>
<h5 id=删除remove>删除remove</h5>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=c1>// 移除并返回队头元素。如果队列为空将返回null
</span><span class=c1></span><span class=nd>@SuppressWarnings</span><span class=o>(</span><span class=s>&#34;unchecked&#34;</span><span class=o>)</span>
<span class=kd>public</span> <span class=n>E</span> <span class=nf>poll</span><span class=o>()</span> <span class=o>{</span>
    <span class=c1>// 队列为空 返回null
</span><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>size</span> <span class=o>==</span> <span class=n>0</span><span class=o>)</span>
        <span class=k>return</span> <span class=kc>null</span><span class=o>;</span>
    <span class=c1>// 最后一个元素位置
</span><span class=c1></span>    <span class=kt>int</span> <span class=n>s</span> <span class=o>=</span> <span class=o>--</span><span class=n>size</span><span class=o>;</span>
    <span class=n>modCount</span><span class=o>++;</span>
    <span class=c1>// 队头 最值元素
</span><span class=c1></span>    <span class=n>E</span> <span class=n>result</span> <span class=o>=</span> <span class=o>(</span><span class=n>E</span><span class=o>)</span> <span class=n>queue</span><span class=o>[</span><span class=n>0</span><span class=o>];</span>
    <span class=c1>// 使用堆数组中最后一个元素替换队头元素  然后下沉使堆有序
</span><span class=c1></span>    <span class=n>E</span> <span class=n>x</span> <span class=o>=</span> <span class=o>(</span><span class=n>E</span><span class=o>)</span> <span class=n>queue</span><span class=o>[</span><span class=n>s</span><span class=o>];</span>
    <span class=c1>// 删除原最后位置元素
</span><span class=c1></span>    <span class=n>queue</span><span class=o>[</span><span class=n>s</span><span class=o>]</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
    <span class=c1>// 如果s不是数组0号元素 即数组只有一个元素s 就将新的根节点s下沉有序
</span><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>s</span> <span class=o>!=</span> <span class=n>0</span><span class=o>)</span>
        <span class=n>siftDown</span><span class=o>(</span><span class=n>0</span><span class=o>,</span> <span class=n>x</span><span class=o>);</span>
    <span class=k>return</span> <span class=n>result</span><span class=o>;</span>
<span class=o>}</span>
</code></pre></td></tr></table>
</div>
</div><h5 id=siftdown源码>siftDown源码</h5>
<p>下面是PriorityQueue的源码（最小优先队列为例，如果是最大优先队列需要交换符号）</p>
<p>在向下筛选时，叶子节点不需要再向下比较筛选，所以比较完最后一个父节点size/2 -1后<code>(size/2)-1 &lt; size/2）</code>，退出循环</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=c1>// 将指定元素在堆中位置为k的向下使堆有序
</span><span class=c1></span><span class=nd>@SuppressWarnings</span><span class=o>(</span><span class=s>&#34;unchecked&#34;</span><span class=o>)</span>
<span class=kd>private</span> <span class=kt>void</span> <span class=nf>siftDownComparable</span><span class=o>(</span><span class=kt>int</span> <span class=n>k</span><span class=o>,</span> <span class=n>E</span> <span class=n>x</span><span class=o>)</span> <span class=o>{</span>
    <span class=n>Comparable</span><span class=o>&lt;?</span> <span class=kd>super</span> <span class=n>E</span><span class=o>&gt;</span> <span class=n>key</span> <span class=o>=</span> <span class=o>(</span><span class=n>Comparable</span><span class=o>&lt;?</span> <span class=kd>super</span> <span class=n>E</span><span class=o>&gt;)</span><span class=n>x</span><span class=o>;</span>
    <span class=c1>//表示队列中最后一个元素的父节点的下一个节点如：4号左右分别9.10下标子节点。half=size=11 /2=5节点;
</span><span class=c1></span>    <span class=kt>int</span> <span class=n>half</span> <span class=o>=</span> <span class=n>size</span> <span class=o>&gt;&gt;&gt;</span> <span class=n>1</span><span class=o>;</span>        <span class=c1>// loop while a non-leaf
</span><span class=c1></span>    <span class=c1>// 将指定位置节点循环到最后一个父节点(size/2)-1时为止，叶子节点不需要向下有序了
</span><span class=c1></span>    <span class=k>while</span> <span class=o>(</span><span class=n>k</span> <span class=o>&lt;</span> <span class=n>half</span><span class=o>)</span> <span class=o>{</span>
        <span class=c1>// k的左子节点
</span><span class=c1></span>        <span class=kt>int</span> <span class=n>child</span> <span class=o>=</span> <span class=o>(</span><span class=n>k</span> <span class=o>&lt;&lt;</span> <span class=n>1</span><span class=o>)</span> <span class=o>+</span> <span class=n>1</span><span class=o>;</span> <span class=c1>// assume left child is least
</span><span class=c1></span>        <span class=n>Object</span> <span class=n>c</span> <span class=o>=</span> <span class=n>queue</span><span class=o>[</span><span class=n>child</span><span class=o>];</span>
        <span class=kt>int</span> <span class=n>right</span> <span class=o>=</span> <span class=n>child</span> <span class=o>+</span> <span class=n>1</span><span class=o>;</span>
        <span class=c1>// 取小的子节点
</span><span class=c1></span>        <span class=c1>// 如果右子节点存在且比左子节点小就将右子节点更新为小的节点
</span><span class=c1></span>        <span class=k>if</span> <span class=o>(</span><span class=n>right</span> <span class=o>&lt;</span> <span class=n>size</span> <span class=o>&amp;&amp;</span>
            <span class=o>((</span><span class=n>Comparable</span><span class=o>&lt;?</span> <span class=kd>super</span> <span class=n>E</span><span class=o>&gt;)</span> <span class=n>c</span><span class=o>).</span><span class=na>compareTo</span><span class=o>((</span><span class=n>E</span><span class=o>)</span> <span class=n>queue</span><span class=o>[</span><span class=n>right</span><span class=o>])</span> <span class=o>&gt;</span> <span class=n>0</span><span class=o>)</span>
            <span class=n>c</span> <span class=o>=</span> <span class=n>queue</span><span class=o>[</span><span class=n>child</span> <span class=o>=</span> <span class=n>right</span><span class=o>];</span>
        <span class=c1>// 如果key比子节点小或等于就退出
</span><span class=c1></span>        <span class=k>if</span> <span class=o>(</span><span class=n>key</span><span class=o>.</span><span class=na>compareTo</span><span class=o>((</span><span class=n>E</span><span class=o>)</span> <span class=n>c</span><span class=o>)</span> <span class=o>&lt;=</span> <span class=n>0</span><span class=o>)</span>
            <span class=k>break</span><span class=o>;</span>
        <span class=c1>// 交换位置
</span><span class=c1></span>        <span class=n>queue</span><span class=o>[</span><span class=n>k</span><span class=o>]</span> <span class=o>=</span> <span class=n>c</span><span class=o>;</span>
        <span class=n>k</span> <span class=o>=</span> <span class=n>child</span><span class=o>;</span>
    <span class=o>}</span>
    <span class=n>queue</span><span class=o>[</span><span class=n>k</span><span class=o>]</span> <span class=o>=</span> <span class=n>key</span><span class=o>;</span>
<span class=o>}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id=堆有序构造heapify>堆有序构造heapify</h4>
<p>如何使无序数组堆有序化，对于只有3个节点堆，只要对根节点siftDown，将较大的子节点交换上来，此时这个堆有序。</p>
<p>如果将数组看作一个个子堆，从有序子堆构造更大的子堆也只要对大子堆根节点siftDown较大的子节点交换上来，就使得整个堆有序了</p>
<p><img src=../../../assets/images/b49a5c19-cc6c-407b-91ec-4a8fc7884008.png alt></p>
<h5 id=heapify源码>heapify源码</h5>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=c1>// 将一个无序堆从最后的父节点开始向下筛选 直到根节点 使堆有序
</span><span class=c1></span><span class=nd>@SuppressWarnings</span><span class=o>(</span><span class=s>&#34;unchecked&#34;</span><span class=o>)</span>
<span class=kd>private</span> <span class=kt>void</span> <span class=nf>heapify</span><span class=o>()</span> <span class=o>{</span>
    <span class=c1>// 从最后一个父节点(size/2)-1开始直到根节点0 进行向下筛选操作
</span><span class=c1></span>    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=o>(</span><span class=n>size</span> <span class=o>&gt;&gt;&gt;</span> <span class=n>1</span><span class=o>)</span> <span class=o>-</span> <span class=n>1</span><span class=o>;</span> <span class=n>i</span> <span class=o>&gt;=</span> <span class=n>0</span><span class=o>;</span> <span class=n>i</span><span class=o>--)</span>
        <span class=n>siftDown</span><span class=o>(</span><span class=n>i</span><span class=o>,</span> <span class=o>(</span><span class=n>E</span><span class=o>)</span> <span class=n>queue</span><span class=o>[</span><span class=n>i</span><span class=o>]);</span>
<span class=o>}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id=堆排序>堆排序</h3>
<p>堆构造不能使堆数组下标有序，只有根节点是最大，左右子节点顺序不定，如果能将最大的根节点放到数组最后，下一个第二大节点放到数组倒数第二，如此就可有序</p>
<p>可以用与根交换上来的数组最后节点使重新对根节点构造即heapify siftDown，使新根节点在重新变成最大的（排除之前最大的）</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>    3           2               1
   / \  =&gt;     / \      =&gt;     / \
  1   2       1   3           2   3
</code></pre></td></tr></table>
</div>
</div><h4 id=源码>源码</h4>
<p><a test href=https://leetcode-cn.com/problems/sort-an-array/>Sort an Array</a></p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=kt>int</span><span class=o>[]</span> <span class=nf>sortArray</span><span class=o>(</span><span class=kt>int</span><span class=o>[]</span> <span class=n>nums</span><span class=o>)</span> <span class=o>{</span>
    <span class=n>headSort</span><span class=o>(</span><span class=n>nums</span><span class=o>);</span>
    <span class=k>return</span> <span class=n>nums</span><span class=o>;</span>
<span class=o>}</span>

<span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>headSort</span><span class=o>(</span><span class=kt>int</span><span class=o>[]</span> <span class=n>a</span><span class=o>)</span> <span class=o>{</span>
    <span class=c1>// build max head
</span><span class=c1></span>    <span class=kt>int</span> <span class=n>len</span> <span class=o>=</span> <span class=n>a</span><span class=o>.</span><span class=na>length</span><span class=o>;</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=o>(</span><span class=n>len</span> <span class=o>/</span> <span class=n>2</span><span class=o>)</span> <span class=o>-</span> <span class=n>1</span><span class=o>;</span> <span class=n>i</span> <span class=o>&gt;=</span> <span class=n>0</span><span class=o>;</span> <span class=n>i</span><span class=o>--)</span> <span class=o>{</span>
        <span class=n>siftDown</span><span class=o>(</span><span class=n>a</span><span class=o>,</span> <span class=n>i</span><span class=o>,</span> <span class=n>len</span> <span class=o>-</span> <span class=n>1</span><span class=o>);</span>
    <span class=o>}</span>
    <span class=c1>// sort
</span><span class=c1></span>    <span class=k>while</span> <span class=o>(--</span><span class=n>len</span> <span class=o>&gt;</span> <span class=n>0</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>swap</span><span class=o>(</span><span class=n>a</span><span class=o>,</span> <span class=n>0</span><span class=o>,</span> <span class=n>len</span><span class=o>);</span>
        <span class=n>siftDown</span><span class=o>(</span><span class=n>a</span><span class=o>,</span> <span class=n>0</span><span class=o>,</span> <span class=n>len</span> <span class=o>-</span> <span class=n>1</span><span class=o>);</span>
    <span class=o>}</span>
<span class=o>}</span>

<span class=c1>// max head
</span><span class=c1></span><span class=kd>private</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>siftDown</span><span class=o>(</span><span class=kt>int</span><span class=o>[]</span> <span class=n>a</span><span class=o>,</span> <span class=kt>int</span> <span class=n>start</span><span class=o>,</span> <span class=kt>int</span> <span class=n>end</span><span class=o>)</span> <span class=o>{</span>
    <span class=kt>int</span> <span class=n>child</span><span class=o>;</span>
    <span class=k>while</span> <span class=o>((</span><span class=n>child</span> <span class=o>=</span> <span class=n>2</span> <span class=o>*</span> <span class=n>start</span> <span class=o>+</span> <span class=n>1</span><span class=o>)</span> <span class=o>&lt;=</span> <span class=n>end</span><span class=o>)</span> <span class=o>{</span>
        <span class=kt>int</span> <span class=n>rightChild</span> <span class=o>=</span> <span class=n>child</span> <span class=o>+</span> <span class=n>1</span><span class=o>;</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>rightChild</span> <span class=o>&lt;=</span> <span class=n>end</span> <span class=o>&amp;&amp;</span> <span class=n>a</span><span class=o>[</span><span class=n>child</span><span class=o>]</span> <span class=o>&lt;</span> <span class=n>a</span><span class=o>[</span><span class=n>rightChild</span><span class=o>])</span> <span class=o>{</span>
            <span class=n>child</span> <span class=o>=</span> <span class=n>rightChild</span><span class=o>;</span>
        <span class=o>}</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>a</span><span class=o>[</span><span class=n>child</span><span class=o>]</span> <span class=o>&lt;=</span> <span class=n>a</span><span class=o>[</span><span class=n>start</span><span class=o>])</span> <span class=o>{</span>
            <span class=k>break</span><span class=o>;</span>
        <span class=o>}</span>
        <span class=n>swap</span><span class=o>(</span><span class=n>a</span><span class=o>,</span> <span class=n>start</span><span class=o>,</span> <span class=n>child</span><span class=o>);</span>
        <span class=n>start</span> <span class=o>=</span> <span class=n>child</span><span class=o>;</span>
    <span class=o>}</span>
<span class=o>}</span>

<span class=kd>private</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>swap</span><span class=o>(</span><span class=kt>int</span><span class=o>[]</span> <span class=n>a</span><span class=o>,</span> <span class=kt>int</span> <span class=n>i</span><span class=o>,</span> <span class=kt>int</span> <span class=n>j</span><span class=o>)</span> <span class=o>{</span>
    <span class=kt>int</span> <span class=n>temp</span> <span class=o>=</span> <span class=n>a</span><span class=o>[</span><span class=n>i</span><span class=o>];</span>
    <span class=n>a</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>=</span> <span class=n>a</span><span class=o>[</span><span class=n>j</span><span class=o>];</span>
    <span class=n>a</span><span class=o>[</span><span class=n>j</span><span class=o>]</span> <span class=o>=</span> <span class=n>temp</span><span class=o>;</span>
<span class=o>}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id=类结构>类结构</h2>
<p><img src=../../../assets/images/4a1f4916-b442-4c50-aacc-c55733e37099.png alt></p>
<h3 id=构造器>构造器</h3>
<p>构造器需要对堆数组和可能指定的比较器comparator初始化，还有如果使用集合初始化PriorityQueue时需要考虑集合是否有序。</p>
<p>下面使用两个典型的构造器说明，其他的构造器调用或调用相同的方法</p>
<h4 id=一般初始化>一般初始化</h4>
<p>优先队列创建的堆数组最小为1，默认构造器创建的大小为1，在容量不够时自动扩容</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=nf>PriorityQueue</span><span class=o>(</span><span class=kt>int</span> <span class=n>initialCapacity</span><span class=o>,</span>
                        <span class=n>Comparator</span><span class=o>&lt;?</span> <span class=kd>super</span> <span class=n>E</span><span class=o>&gt;</span> <span class=n>comparator</span><span class=o>)</span> <span class=o>{</span>
    <span class=c1>// Note: This restriction of at least one is not actually needed,
</span><span class=c1></span>    <span class=c1>// but continues for 1.5 compatibility
</span><span class=c1></span>    <span class=c1>//至少容量为1是为了兼容性
</span><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>initialCapacity</span> <span class=o>&lt;</span> <span class=n>1</span><span class=o>)</span>
        <span class=k>throw</span> <span class=k>new</span> <span class=n>IllegalArgumentException</span><span class=o>();</span>
    <span class=k>this</span><span class=o>.</span><span class=na>queue</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Object</span><span class=o>[</span><span class=n>initialCapacity</span><span class=o>];</span>
    <span class=k>this</span><span class=o>.</span><span class=na>comparator</span> <span class=o>=</span> <span class=n>comparator</span><span class=o>;</span>
<span class=o>}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id=集合初始化>集合初始化</h4>
<p>通过集合初始化时需要考虑原来集合是否有序，如果原来集合有序，即保证堆有序，而下标0的元素一定是最值。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=c1>// 根据指定集合的元素创建优先队列，如果指定的collection是SortedSet或优先队列，
</span><span class=c1>// 则使用相同的顺序排序 否则使用自然顺序
</span><span class=c1></span><span class=nd>@SuppressWarnings</span><span class=o>(</span><span class=s>&#34;unchecked&#34;</span><span class=o>)</span>
<span class=kd>public</span> <span class=nf>PriorityQueue</span><span class=o>(</span><span class=n>Collection</span><span class=o>&lt;?</span> <span class=kd>extends</span> <span class=n>E</span><span class=o>&gt;</span> <span class=n>c</span><span class=o>)</span> <span class=o>{</span>
    <span class=c1>// 如果是SortedSet
</span><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>c</span> <span class=k>instanceof</span> <span class=n>SortedSet</span><span class=o>&lt;?&gt;)</span> <span class=o>{</span>
        <span class=n>SortedSet</span><span class=o>&lt;?</span> <span class=kd>extends</span> <span class=n>E</span><span class=o>&gt;</span> <span class=n>ss</span> <span class=o>=</span> <span class=o>(</span><span class=n>SortedSet</span><span class=o>&lt;?</span> <span class=kd>extends</span> <span class=n>E</span><span class=o>&gt;)</span> <span class=n>c</span><span class=o>;</span>
        <span class=k>this</span><span class=o>.</span><span class=na>comparator</span> <span class=o>=</span> <span class=o>(</span><span class=n>Comparator</span><span class=o>&lt;?</span> <span class=kd>super</span> <span class=n>E</span><span class=o>&gt;)</span> <span class=n>ss</span><span class=o>.</span><span class=na>comparator</span><span class=o>();</span>
        <span class=c1>// 从集合中初始化到堆数组中 检查集合元素是否存在null 由于本身是有序的 queue[0]一定是最值 不需要使堆完全有序
</span><span class=c1></span>        <span class=n>initElementsFromCollection</span><span class=o>(</span><span class=n>ss</span><span class=o>);</span>
    <span class=o>}</span>
    <span class=c1>// 如果是优先队列
</span><span class=c1></span>    <span class=k>else</span> <span class=k>if</span> <span class=o>(</span><span class=n>c</span> <span class=k>instanceof</span> <span class=n>PriorityQueue</span><span class=o>&lt;?&gt;)</span> <span class=o>{</span>
        <span class=n>PriorityQueue</span><span class=o>&lt;?</span> <span class=kd>extends</span> <span class=n>E</span><span class=o>&gt;</span> <span class=n>pq</span> <span class=o>=</span> <span class=o>(</span><span class=n>PriorityQueue</span><span class=o>&lt;?</span> <span class=kd>extends</span> <span class=n>E</span><span class=o>&gt;)</span> <span class=n>c</span><span class=o>;</span>
        <span class=k>this</span><span class=o>.</span><span class=na>comparator</span> <span class=o>=</span> <span class=o>(</span><span class=n>Comparator</span><span class=o>&lt;?</span> <span class=kd>super</span> <span class=n>E</span><span class=o>&gt;)</span> <span class=n>pq</span><span class=o>.</span><span class=na>comparator</span><span class=o>();</span>
        <span class=c1>// 直接使用PriorityQueue.toArray的数组 堆完整有序 
</span><span class=c1></span>        <span class=n>initFromPriorityQueue</span><span class=o>(</span><span class=n>pq</span><span class=o>);</span>
    <span class=o>}</span>
    <span class=k>else</span> <span class=o>{</span>
        <span class=k>this</span><span class=o>.</span><span class=na>comparator</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
        <span class=c1>// 将指定的集合添加到priorityqueue中并使堆有序
</span><span class=c1></span>        <span class=n>initFromCollection</span><span class=o>(</span><span class=n>c</span><span class=o>);</span>
    <span class=o>}</span>
<span class=o>}</span>

<span class=c1>// 从指定集合Collection中 初始化堆数组  此时堆数组无序
</span><span class=c1></span><span class=kd>private</span> <span class=kt>void</span> <span class=nf>initElementsFromCollection</span><span class=o>(</span><span class=n>Collection</span><span class=o>&lt;?</span> <span class=kd>extends</span> <span class=n>E</span><span class=o>&gt;</span> <span class=n>c</span><span class=o>)</span> <span class=o>{</span>
    <span class=n>Object</span><span class=o>[]</span> <span class=n>a</span> <span class=o>=</span> <span class=n>c</span><span class=o>.</span><span class=na>toArray</span><span class=o>();</span>
    <span class=c1>// If c.toArray incorrectly doesn&#39;t return Object[], copy it.
</span><span class=c1></span>    <span class=c1>// 保证底层数组queue为Object[]类型
</span><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>a</span><span class=o>.</span><span class=na>getClass</span><span class=o>()</span> <span class=o>!=</span> <span class=n>Object</span><span class=o>[].</span><span class=na>class</span><span class=o>)</span>
        <span class=n>a</span> <span class=o>=</span> <span class=n>Arrays</span><span class=o>.</span><span class=na>copyOf</span><span class=o>(</span><span class=n>a</span><span class=o>,</span> <span class=n>a</span><span class=o>.</span><span class=na>length</span><span class=o>,</span> <span class=n>Object</span><span class=o>[].</span><span class=na>class</span><span class=o>);</span>
    <span class=kt>int</span> <span class=n>len</span> <span class=o>=</span> <span class=n>a</span><span class=o>.</span><span class=na>length</span><span class=o>;</span>
    <span class=c1>// 如果有比较器 扫描容器数组中元素不含null元素
</span><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>len</span> <span class=o>==</span> <span class=n>1</span> <span class=o>||</span> <span class=k>this</span><span class=o>.</span><span class=na>comparator</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span>
        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>len</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span>
            <span class=k>if</span> <span class=o>(</span><span class=n>a</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
                <span class=k>throw</span> <span class=k>new</span> <span class=n>NullPointerException</span><span class=o>();</span>
    <span class=k>this</span><span class=o>.</span><span class=na>queue</span> <span class=o>=</span> <span class=n>a</span><span class=o>;</span>
    <span class=k>this</span><span class=o>.</span><span class=na>size</span> <span class=o>=</span> <span class=n>a</span><span class=o>.</span><span class=na>length</span><span class=o>;</span>
<span class=o>}</span>

<span class=cm>/**
</span><span class=cm> * Initializes queue array with elements from the given Collection.
</span><span class=cm> *
</span><span class=cm> * @param c the collection
</span><span class=cm> */</span>
<span class=c1>// 将指定的集合添加到priorityqueue中并使堆有序
</span><span class=c1></span><span class=kd>private</span> <span class=kt>void</span> <span class=nf>initFromCollection</span><span class=o>(</span><span class=n>Collection</span><span class=o>&lt;?</span> <span class=kd>extends</span> <span class=n>E</span><span class=o>&gt;</span> <span class=n>c</span><span class=o>)</span> <span class=o>{</span>
    <span class=c1>// 将集合元素初始化到优先队列queue中
</span><span class=c1></span>    <span class=n>initElementsFromCollection</span><span class=o>(</span><span class=n>c</span><span class=o>);</span>
    <span class=c1>// 使堆有序 
</span><span class=c1></span>    <span class=n>heapify</span><span class=o>();</span>
<span class=o>}</span>

<span class=c1>// 如果是PriorityQueue就直接使用toArray的数组 否则调用initFromCollection
</span><span class=c1></span><span class=kd>private</span> <span class=kt>void</span> <span class=nf>initFromPriorityQueue</span><span class=o>(</span><span class=n>PriorityQueue</span><span class=o>&lt;?</span> <span class=kd>extends</span> <span class=n>E</span><span class=o>&gt;</span> <span class=n>c</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>c</span><span class=o>.</span><span class=na>getClass</span><span class=o>()</span> <span class=o>==</span> <span class=n>PriorityQueue</span><span class=o>.</span><span class=na>class</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>this</span><span class=o>.</span><span class=na>queue</span> <span class=o>=</span> <span class=n>c</span><span class=o>.</span><span class=na>toArray</span><span class=o>();</span>
        <span class=k>this</span><span class=o>.</span><span class=na>size</span> <span class=o>=</span> <span class=n>c</span><span class=o>.</span><span class=na>size</span><span class=o>();</span>
    <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
        <span class=n>initFromCollection</span><span class=o>(</span><span class=n>c</span><span class=o>);</span>
    <span class=o>}</span>
<span class=o>}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id=注意>注意</h4>
<ul>
<li>优先队列创建的堆数组最小为1，默认构造器创建的大小为11，在容量不够时自动扩容</li>
<li>通过集合初始化时需要考虑原来集合是否有序，如果原来集合有序，即保证堆有序，而下标0的元素一定是最值。</li>
</ul>
<p>下面使用一个有序集合构造为优先队列的示例说明 有序数组本就堆有序</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=kd>static</span> <span class=kt>void</span> <span class=nf>constructoraddAllTest</span><span class=o>()</span> <span class=o>{</span>
    <span class=n>SortedSet</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>set</span> <span class=o>=</span> <span class=k>new</span> <span class=n>TreeSet</span><span class=o>&lt;&gt;();</span>
    <span class=n>set</span><span class=o>.</span><span class=na>addAll</span><span class=o>(</span><span class=n>Arrays</span><span class=o>.</span><span class=na>asList</span><span class=o>(</span><span class=n>1</span><span class=o>,</span> <span class=n>3</span><span class=o>,</span> <span class=n>6</span><span class=o>,</span> <span class=n>7</span><span class=o>,</span> <span class=n>9</span><span class=o>,</span> <span class=n>12</span><span class=o>,</span> <span class=n>15</span><span class=o>));</span>
    <span class=n>PriorityQueue</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>queue</span> <span class=o>=</span> <span class=k>new</span> <span class=n>PriorityQueue</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;(</span><span class=n>set</span><span class=o>);</span>
    <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;before:&#34;</span> <span class=o>+</span> <span class=n>Arrays</span><span class=o>.</span><span class=na>toString</span><span class=o>(</span><span class=n>queue</span><span class=o>.</span><span class=na>queue</span><span class=o>));</span>
    <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;after:&#34;</span><span class=o>);</span>
    <span class=k>while</span> <span class=o>(</span><span class=n>queue</span><span class=o>.</span><span class=na>poll</span><span class=o>()</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>Arrays</span><span class=o>.</span><span class=na>toString</span><span class=o>(</span><span class=n>queue</span><span class=o>.</span><span class=na>queue</span><span class=o>));</span>
    <span class=o>}</span>
<span class=o>}</span>
<span class=cm>/*输出：
</span><span class=cm>before:[1, 3, 6, 7, 9, 12, 15]
</span><span class=cm>after:
</span><span class=cm>[3, 7, 6, 15, 9, 12, null]
</span><span class=cm>[6, 7, 12, 15, 9, null, null]
</span><span class=cm>[7, 9, 12, 15, null, null, null]
</span><span class=cm>[9, 15, 12, null, null, null, null]
</span><span class=cm>[12, 15, null, null, null, null, null]
</span><span class=cm>[15, null, null, null, null, null, null]
</span><span class=cm>[null, null, null, null, null, null, null]
</span><span class=cm>*/</span>
</code></pre></td></tr></table>
</div>
</div><p>下面是模拟堆数组第一次出队的步骤：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>经过集合构造器的堆数组：	[1, 3, 6, 7, 9, 12, 15]

							1				&lt;--出队
					3				6
				7		9		12		15	&lt;--到堆顶替换
			--------------------------------	
							15				&lt;--用数组最后元素替换
					3				6
				7		9		12		
			--------------------------------
							3
					15				6		&lt;--下沉　取子节点中小的交换
				7		9		12
			--------------------------------
							3
					7				6
				15		9		12			&lt;--完成下沉　
			--------------------------------
		一次出队后堆数组：	[3, 7, 6, 15, 9, 12, null]		
</code></pre></td></tr></table>
</div>
</div><ul>
<li>通过构造器构造的堆数组一定时堆有序的。不存在在插入删除时才有序，如果一开始堆数组不保证顺序，插入仅下沉和删除仅上浮不可能保证队头是最值了</li>
</ul>
<h3 id=扩容>扩容</h3>
<p>PriorityQueue的扩容比较简单，当数组较小时(&lt;64)扩大为数组的两倍，否则将扩大50%</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=cm>/**
</span><span class=cm> * Increases the capacity of the array.
</span><span class=cm> *
</span><span class=cm> * @param minCapacity the desired minimum capacity
</span><span class=cm> */</span>
<span class=kd>private</span> <span class=kt>void</span> <span class=nf>grow</span><span class=o>(</span><span class=kt>int</span> <span class=n>minCapacity</span><span class=o>)</span> <span class=o>{</span>
    <span class=c1>// 旧数组容量
</span><span class=c1></span>    <span class=kt>int</span> <span class=n>oldCapacity</span> <span class=o>=</span> <span class=n>queue</span><span class=o>.</span><span class=na>length</span><span class=o>;</span>
    <span class=c1>// Double size if small; else grow by 50%
</span><span class=c1></span>    <span class=c1>// 如果数组过小(&lt;64)就扩大两倍，否则扩大一半50%
</span><span class=c1></span>    <span class=kt>int</span> <span class=n>newCapacity</span> <span class=o>=</span> <span class=n>oldCapacity</span> <span class=o>+</span> <span class=o>((</span><span class=n>oldCapacity</span> <span class=o>&lt;</span> <span class=n>64</span><span class=o>)</span> <span class=o>?</span>
                                    <span class=o>(</span><span class=n>oldCapacity</span> <span class=o>+</span> <span class=n>2</span><span class=o>)</span> <span class=o>:</span>
                                    <span class=o>(</span><span class=n>oldCapacity</span> <span class=o>&gt;&gt;</span> <span class=n>1</span><span class=o>));</span>
    <span class=c1>// overflow-conscious code
</span><span class=c1></span>    <span class=c1>// 如果增加50%后超过最大容量，没有溢出就使用int最大或最大容量值
</span><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>newCapacity</span> <span class=o>-</span> <span class=n>MAX_ARRAY_SIZE</span> <span class=o>&gt;</span> <span class=n>0</span><span class=o>)</span>
        <span class=n>newCapacity</span> <span class=o>=</span> <span class=n>hugeCapacity</span><span class=o>(</span><span class=n>minCapacity</span><span class=o>);</span>
    <span class=c1>// 复制到新数组长度为newCapaciry
</span><span class=c1></span>    <span class=n>queue</span> <span class=o>=</span> <span class=n>Arrays</span><span class=o>.</span><span class=na>copyOf</span><span class=o>(</span><span class=n>queue</span><span class=o>,</span> <span class=n>newCapacity</span><span class=o>);</span>
<span class=o>}</span>

<span class=kd>private</span> <span class=kd>static</span> <span class=kt>int</span> <span class=nf>hugeCapacity</span><span class=o>(</span><span class=kt>int</span> <span class=n>minCapacity</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>minCapacity</span> <span class=o>&lt;</span> <span class=n>0</span><span class=o>)</span> <span class=c1>// overflow
</span><span class=c1></span>        <span class=k>throw</span> <span class=k>new</span> <span class=n>OutOfMemoryError</span><span class=o>();</span>
    <span class=k>return</span> <span class=o>(</span><span class=n>minCapacity</span> <span class=o>&gt;</span> <span class=n>MAX_ARRAY_SIZE</span><span class=o>)</span> <span class=o>?</span>
        <span class=n>Integer</span><span class=o>.</span><span class=na>MAX_VALUE</span> <span class=o>:</span>
        <span class=n>MAX_ARRAY_SIZE</span><span class=o>;</span>
<span class=o>}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id=迭代器>迭代器</h3>
<p>PriorityQueue的迭代器 <em><strong>不保证顺序遍历</strong></em> ，在需要顺序遍历时请使用<code>Arrays.sort(pq.toArray())</code></p>
<blockquote>
<p>This class and its iterator implement all of the optional methods of the Collection and Iterator interfaces. The Iterator provided in method iterator() and the Spliterator provided in method spliterator() are not guaranteed to traverse the elements of the priority queue in any particular order. If you need ordered traversal, consider using Arrays.sort(pq.toArray()).</p>
</blockquote>
<p>迭代器不保证顺序遍历在实现中有两点：</p>
<ul>
<li>迭代器是在堆数组中一个个遍历，无法保证优先队列的顺序</li>
<li>由于个别元素的特殊性，在删除元素时替换元素上浮，导致已经遍历的位置替换为新元素，所以这样的元素均放置在一个deque中，priorityqueue遍历完成后再遍历deque，无法保证顺序</li>
</ul>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=kd>private</span> <span class=kd>final</span> <span class=kd>class</span> <span class=nc>Itr</span> <span class=kd>implements</span> <span class=n>Iterator</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=o>{</span>
    <span class=cm>/**
</span><span class=cm>     * Index (into queue array) of element to be returned by
</span><span class=cm>     * subsequent call to next.
</span><span class=cm>     */</span>
    <span class=c1>// 下一个调用返回的元素下标
</span><span class=c1></span>    <span class=kd>private</span> <span class=kt>int</span> <span class=n>cursor</span> <span class=o>=</span> <span class=n>0</span><span class=o>;</span>

    <span class=cm>/**
</span><span class=cm>     * Index of element returned by most recent call to next,
</span><span class=cm>     * unless that element came from the forgetMeNot list.
</span><span class=cm>     * Set to -1 if element is deleted by a call to remove.
</span><span class=cm>     */</span>
    <span class=kd>private</span> <span class=kt>int</span> <span class=n>lastRet</span> <span class=o>=</span> <span class=o>-</span><span class=n>1</span><span class=o>;</span>

    <span class=cm>/**
</span><span class=cm>     * A queue of elements that were moved from the unvisited portion of
</span><span class=cm>     * the heap into the visited portion as a result of &#34;unlucky&#34; element
</span><span class=cm>     * removals during the iteration.  (Unlucky element removals are those
</span><span class=cm>     * that require a siftup instead of a siftdown.)  We must visit all of
</span><span class=cm>     * the elements in this list to complete the iteration.  We do this
</span><span class=cm>     * after we&#39;ve completed the &#34;normal&#34; iteration.
</span><span class=cm>     *
</span><span class=cm>     * We expect that most iterations, even those involving removals,
</span><span class=cm>     * will not need to store elements in this field.
</span><span class=cm>     */</span>
    <span class=cm>/*
</span><span class=cm>        * 由于在迭代器中删除堆数组中的某个元素，在使用堆数组中最后一个元素替换时,该元素比删除元素
</span><span class=cm>        * 的父节点更小（默认最小堆），会使该元素上浮(siftUp)导致该元素替换到已经遍历过的位置，
</span><span class=cm>        * 此时使用deque存储该元素并在最后再遍历
</span><span class=cm>        * 
</span><span class=cm>        */</span>
    <span class=kd>private</span> <span class=n>ArrayDeque</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>forgetMeNot</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>

    <span class=cm>/**
</span><span class=cm>     * Element returned by the most recent call to next iff that
</span><span class=cm>     * element was drawn from the forgetMeNot list.
</span><span class=cm>     */</span>
    <span class=c1>// 在遍历forgetMeNot时保存最近访问的元素
</span><span class=c1></span>    <span class=kd>private</span> <span class=n>E</span> <span class=n>lastRetElt</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>

    <span class=cm>/**
</span><span class=cm>     * The modCount value that the iterator believes that the backing
</span><span class=cm>     * Queue should have.  If this expectation is violated, the iterator
</span><span class=cm>     * has detected concurrent modification.
</span><span class=cm>     */</span>
    <span class=kd>private</span> <span class=kt>int</span> <span class=n>expectedModCount</span> <span class=o>=</span> <span class=n>modCount</span><span class=o>;</span>

    <span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>hasNext</span><span class=o>()</span> <span class=o>{</span>
        <span class=k>return</span> <span class=n>cursor</span> <span class=o>&lt;</span> <span class=n>size</span> <span class=o>||</span>
            <span class=o>(</span><span class=n>forgetMeNot</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>forgetMeNot</span><span class=o>.</span><span class=na>isEmpty</span><span class=o>());</span>
    <span class=o>}</span>

    <span class=nd>@SuppressWarnings</span><span class=o>(</span><span class=s>&#34;unchecked&#34;</span><span class=o>)</span>
    <span class=kd>public</span> <span class=n>E</span> <span class=nf>next</span><span class=o>()</span> <span class=o>{</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>expectedModCount</span> <span class=o>!=</span> <span class=n>modCount</span><span class=o>)</span>
            <span class=k>throw</span> <span class=k>new</span> <span class=n>ConcurrentModificationException</span><span class=o>();</span>
        <span class=c1>// 以堆数组的顺序 返回下一个元素 即迭代器不保证优先队列的顺序
</span><span class=c1></span>        <span class=k>if</span> <span class=o>(</span><span class=n>cursor</span> <span class=o>&lt;</span> <span class=n>size</span><span class=o>)</span>
            <span class=k>return</span> <span class=o>(</span><span class=n>E</span><span class=o>)</span> <span class=n>queue</span><span class=o>[</span><span class=n>lastRet</span> <span class=o>=</span> <span class=n>cursor</span><span class=o>++];</span>
        <span class=c1>// 如果有unlucky元素 就遍历
</span><span class=c1></span>        <span class=k>if</span> <span class=o>(</span><span class=n>forgetMeNot</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
            <span class=n>lastRet</span> <span class=o>=</span> <span class=o>-</span><span class=n>1</span><span class=o>;</span>
            <span class=n>lastRetElt</span> <span class=o>=</span> <span class=n>forgetMeNot</span><span class=o>.</span><span class=na>poll</span><span class=o>();</span>
            <span class=k>if</span> <span class=o>(</span><span class=n>lastRetElt</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span>
                <span class=k>return</span> <span class=n>lastRetElt</span><span class=o>;</span>
        <span class=o>}</span>
        <span class=c1>// 如果cursor &gt;= size或 forgetmenot为空返回null
</span><span class=c1></span>        <span class=k>throw</span> <span class=k>new</span> <span class=n>NoSuchElementException</span><span class=o>();</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>remove</span><span class=o>()</span> <span class=o>{</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>expectedModCount</span> <span class=o>!=</span> <span class=n>modCount</span><span class=o>)</span>
            <span class=k>throw</span> <span class=k>new</span> <span class=n>ConcurrentModificationException</span><span class=o>();</span>
        <span class=c1>// 正常next后删除
</span><span class=c1></span>        <span class=k>if</span> <span class=o>(</span><span class=n>lastRet</span> <span class=o>!=</span> <span class=o>-</span><span class=n>1</span><span class=o>)</span> <span class=o>{</span>
            <span class=c1>// 删除最近的访问元素  接受可能的unlucky元素
</span><span class=c1></span>            <span class=n>E</span> <span class=n>moved</span> <span class=o>=</span> <span class=n>PriorityQueue</span><span class=o>.</span><span class=na>this</span><span class=o>.</span><span class=na>removeAt</span><span class=o>(</span><span class=n>lastRet</span><span class=o>);</span>
            <span class=n>lastRet</span> <span class=o>=</span> <span class=o>-</span><span class=n>1</span><span class=o>;</span>
            <span class=c1>// 删除正常 无unlucky元素
</span><span class=c1></span>            <span class=k>if</span> <span class=o>(</span><span class=n>moved</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
                <span class=n>cursor</span><span class=o>--;</span>
            <span class=c1>// 存在unlucky元素 添加进入forgetNot队列
</span><span class=c1></span>            <span class=k>else</span> <span class=o>{</span>
                <span class=k>if</span> <span class=o>(</span><span class=n>forgetMeNot</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
                    <span class=n>forgetMeNot</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayDeque</span><span class=o>&lt;&gt;();</span>
                <span class=n>forgetMeNot</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>moved</span><span class=o>);</span>
            <span class=o>}</span>
        <span class=o>}</span>
        <span class=c1>// 如果是在遍历forgetMeNot时调用remove
</span><span class=c1></span>        <span class=k>else</span> <span class=k>if</span> <span class=o>(</span><span class=n>lastRetElt</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
            <span class=c1>// 删除最近遍历的forgetMeNot的元素
</span><span class=c1></span>            <span class=n>PriorityQueue</span><span class=o>.</span><span class=na>this</span><span class=o>.</span><span class=na>removeEq</span><span class=o>(</span><span class=n>lastRetElt</span><span class=o>);</span>
            <span class=n>lastRetElt</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
        <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
            <span class=k>throw</span> <span class=k>new</span> <span class=n>IllegalStateException</span><span class=o>();</span>
        <span class=o>}</span>
        <span class=n>expectedModCount</span> <span class=o>=</span> <span class=n>modCount</span><span class=o>;</span>
    <span class=o>}</span>
<span class=o>}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id=通用remove实现>通用remove实现</h3>
<p>在不固定remove元素位置时有两种情况：</p>
<h4 id=删除位置为非叶子节点>删除位置为非叶子节点</h4>
<p>都只需要使用堆数组最后一个元素替换并下沉使堆有序，由于堆数组正常情况下是有序的，所以只需要下沉即可，与<a test href=#%e5%88%a0%e9%99%a4remove>二叉堆删除remove</a>一致</p>
<h4 id=删除位置为叶子节点>删除位置为叶子节点</h4>
<p>由于不同父节点的大小无法确定，在最小堆中，存在叶子节点比其他的父节点更小的情况，此时，如果将该叶子节点替换到合适的父节点下，无法下沉，但能上浮即比父节点小。</p>
<p>注意这种情况非常小，需要满足替换元素4 &lt; 被删除元素的父节点6，此时需要上浮操作</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>							1				
					6				3
删除12--&gt;		12			15		7		4	&lt;--最后元素用于替换
			-------------------------------

							1				
					6				3
需要上浮--&gt;		4		15		7
			-------------------------------
							1				
					4				3
   完成	 	6		15		7
			-------------------------------
</code></pre></td></tr></table>
</div>
</div><p>关于removeAt()方法就是由于上述特殊情况的删除才会返回一个特殊值，导致遍历删除时无法保证顺序。removeAt返回null表示正常删除成功，返回一个值表示上浮更新了堆的顺序，删除操作成功</p>
<p>对于迭代器来说是致命的 无法保证顺序，因为已经遍历过的位置被更新了说明之前遍历的顺序是错误的 即返回该元素遍历 由于移除的关系，最后元素i已经不会被获取，所以提前返回该元素</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=cm>/**
</span><span class=cm> * Removes the ith element from queue.
</span><span class=cm> *
</span><span class=cm> * Normally this method leaves the elements at up to i-1,
</span><span class=cm> * inclusive, untouched.  Under these circumstances, it returns
</span><span class=cm> * null.  Occasionally, in order to maintain the heap invariant,
</span><span class=cm> * it must swap a later element of the list with one earlier than
</span><span class=cm> * i.  Under these circumstances, this method returns the element
</span><span class=cm> * that was previously at the end of the list and is now at some
</span><span class=cm> * position before i. This fact is used by iterator.remove so as to
</span><span class=cm> * avoid missing traversing elements.
</span><span class=cm> */</span>
<span class=c1>// 移除数组中指定位置的元素 返回null表示正常删除成功。否则表示迭代异常，返回丢失的元素
</span><span class=c1></span><span class=nd>@SuppressWarnings</span><span class=o>(</span><span class=s>&#34;unchecked&#34;</span><span class=o>)</span>
<span class=kd>private</span> <span class=n>E</span> <span class=nf>removeAt</span><span class=o>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>)</span> <span class=o>{</span>
    <span class=c1>// assert i &gt;= 0 &amp;&amp; i &lt; size;
</span><span class=c1></span>    <span class=n>modCount</span><span class=o>++;</span>
    <span class=c1>// 最后元素的下标
</span><span class=c1></span>    <span class=kt>int</span> <span class=n>s</span> <span class=o>=</span> <span class=o>--</span><span class=n>size</span><span class=o>;</span>
    <span class=c1>// i就是最后元素
</span><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>s</span> <span class=o>==</span> <span class=n>i</span><span class=o>)</span> <span class=c1>// removed last element
</span><span class=c1></span>        <span class=n>queue</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
    <span class=k>else</span> <span class=o>{</span>
        <span class=c1>// 最后元素
</span><span class=c1></span>        <span class=n>E</span> <span class=n>moved</span> <span class=o>=</span> <span class=o>(</span><span class=n>E</span><span class=o>)</span> <span class=n>queue</span><span class=o>[</span><span class=n>s</span><span class=o>];</span>
        <span class=c1>// 删除最后元素
</span><span class=c1></span>        <span class=n>queue</span><span class=o>[</span><span class=n>s</span><span class=o>]</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
        <span class=c1>// 等价于将最后元素移动到删除元素位置，将其下沉有序化
</span><span class=c1></span>        <span class=n>siftDown</span><span class=o>(</span><span class=n>i</span><span class=o>,</span> <span class=n>moved</span><span class=o>);</span>
        <span class=c1>// 当前节点无法下沉 表示最后元素i比小的子节点更小（默认最小堆）
</span><span class=c1></span>        <span class=k>if</span> <span class=o>(</span><span class=n>queue</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>==</span> <span class=n>moved</span><span class=o>)</span> <span class=o>{</span>
            <span class=c1>// 将当前节点上浮
</span><span class=c1></span>            <span class=n>siftUp</span><span class=o>(</span><span class=n>i</span><span class=o>,</span> <span class=n>moved</span><span class=o>);</span>
            <span class=c1>// 如果当前节点能够上浮 表示数组最后元素i比父节点小
</span><span class=c1></span>            <span class=k>if</span> <span class=o>(</span><span class=n>queue</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>!=</span> <span class=n>moved</span><span class=o>)</span>  <span class=o>{</span>
                <span class=cm>/*
</span><span class=cm>                    * 对于迭代器来说是致命的 无法保证顺序，因为已经遍历过的位置被更新了
</span><span class=cm>                    * 说明之前遍历的顺序是错误的 即返回该元素遍历 由于移除的关系，最后元素i
</span><span class=cm>                    * 已经不会被获取，所以提前返回该元素 
</span><span class=cm>                    */</span>
                <span class=k>return</span> <span class=n>moved</span><span class=o>;</span>
            <span class=o>}</span>
        <span class=o>}</span>
    <span class=o>}</span>
    <span class=k>return</span> <span class=kc>null</span><span class=o>;</span>
<span class=o>}</span>
</code></pre></td></tr></table>
</div>
</div><p>参考：</p>
<ul>
<li><a test href=https://algs4.cs.princeton.edu/24pq>2.4 Priority Queues</a></li>
<li><a test href=https://docs.oracle.com/javase/8/docs/api/>Class PriorityQueue</a></li>
</ul>
</div>
</article>
</div>
<script src=https://utteranc.es/client.js repo=navyd/navyd.github.io issue-term=pathname theme=github-light crossorigin=anonymous async></script>
<noscript>Please enable JavaScript to view the <a href=https://github.com/utterance>comments powered by utterances.</a></noscript>
</div>
</main>
<footer id=footer class=footer>
<div class=social-links>
<a href=https://github.com/NavyD/navyd.github.io class="iconfont icon-github" title=github></a>
<a href=https://navyd.github.io/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a>
</div>
<div class=copyright>
<span class=power-by>
由 <a class=hexo-link href=https://gohugo.io>Hugo</a> 强力驱动
</span>
<span class=division>|</span>
<span class=theme-info>
主题 -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a>
</span>
<div class=busuanzi-footer>
<span id=busuanzi_container_site_pv> 本站总访问量 <span id=busuanzi_value_site_pv><img src=/img/spinner.svg alt=spinner.svg></span> 次 </span>
<span class=division>|</span>
<span id=busuanzi_container_site_uv> 本站总访客数 <span id=busuanzi_value_site_uv><img src=/img/spinner.svg alt=spinner.svg></span> 人 </span>
</div>
<span class=copyright-year>
&copy;
2021<span class=heart><i class="iconfont icon-heart"></i></span><span>navyd</span>
</span>
</div>
</footer>
<div class=back-to-top id=back-to-top>
<i class="iconfont icon-up"></i>
</div>
</div>
<script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/timeago.js@3.0.2/dist/timeago.min.js integrity="sha256-jwCP0NAdCBloaIWTWHmW4i3snUNMHUNO+jr9rYd2iOI=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/timeago.js@3.0.2/dist/timeago.locales.min.js integrity="sha256-ZwofwC1Lf/faQCzN7nZtfijVV6hSwxjQMwXL4gn9qU8=" crossorigin=anonymous></script>
<script>var languageCode="en".replace(/-/g,'_').replace(/_(.*)/,function(b,a){return b.replace(a,a.toUpperCase())});timeago().render(document.querySelectorAll('.timeago'),languageCode),timeago.cancel()</script>
<script type=text/javascript src=/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js></script>
</body>
</html>