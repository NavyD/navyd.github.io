<!doctype html><html lang=zh-cn>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge,chrome=1">
<title> - Even - A super concise theme for Hugo</title>
<meta name=renderer content="webkit">
<meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1">
<meta http-equiv=cache-control content="no-transform">
<meta http-equiv=cache-control content="no-siteapp">
<meta name=theme-color content="#f8f5ec">
<meta name=msapplication-navbutton-color content="#f8f5ec">
<meta name=apple-mobile-web-app-capable content="yes">
<meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec">
<meta name=author content="navyd"><meta name=description content="ArrayDeque Deque接口的大小可变数组的实现。 特性： 底层实现：循环数组 没有容量限制，在数组元素装满时自动扩容 禁止插入null元素 作为Stack和Qu"><meta name=keywords content="Hugo,blog,navyd">
<meta name=generator content="Hugo 0.87.0 with theme even">
<link rel=canonical href=https://navyd.github.io/res/java/code-analysis/collections/arraydeque/>
<link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png>
<link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png>
<link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png>
<link rel=manifest href=/manifest.json>
<link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5>
<script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<link href=/sass/main.min.a659bb31b17a54f7792e1bc783fc75b31118e6a175b42337b03fae0b1a3ef2b5.css rel=stylesheet>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous>
<meta property="og:title" content>
<meta property="og:description" content="ArrayDeque Deque接口的大小可变数组的实现。 特性： 底层实现：循环数组 没有容量限制，在数组元素装满时自动扩容 禁止插入null元素 作为Stack和Qu">
<meta property="og:type" content="article">
<meta property="og:url" content="https://navyd.github.io/res/java/code-analysis/collections/arraydeque/"><meta property="article:section" content="res">
<meta itemprop=name content>
<meta itemprop=description content="ArrayDeque Deque接口的大小可变数组的实现。 特性： 底层实现：循环数组 没有容量限制，在数组元素装满时自动扩容 禁止插入null元素 作为Stack和Qu">
<meta itemprop=wordCount content="8344">
<meta itemprop=keywords content><meta name=twitter:card content="summary">
<meta name=twitter:title content>
<meta name=twitter:description content="ArrayDeque Deque接口的大小可变数组的实现。 特性： 底层实现：循环数组 没有容量限制，在数组元素装满时自动扩容 禁止插入null元素 作为Stack和Qu"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]-->
</head>
<body>
<div id=mobile-navbar class=mobile-navbar>
<div class=mobile-header-logo>
<a href=/ class=logo>navyd的个人博客</a>
</div>
<div class=mobile-navbar-icon>
<span></span>
<span></span>
<span></span>
</div>
</div>
<nav id=mobile-menu class="mobile-menu slideout-menu">
<ul class=mobile-menu-list>
<a href=/>
<li class=mobile-menu-item>Home</li>
</a><a href=/post/>
<li class=mobile-menu-item>Archives</li>
</a><a href=/tags/>
<li class=mobile-menu-item>Tags</li>
</a><a href=/categories/>
<li class=mobile-menu-item>Categories</li>
</a>
</ul>
</nav>
<div class=container id=mobile-panel>
<header id=header class=header>
<div class=logo-wrapper>
<a href=/ class=logo>navyd的个人博客</a>
</div>
<nav class=site-navbar>
<ul id=menu class=menu>
<li class=menu-item>
<a class=menu-item-link href=/>Home</a>
</li><li class=menu-item>
<a class=menu-item-link href=/post/>Archives</a>
</li><li class=menu-item>
<a class=menu-item-link href=/tags/>Tags</a>
</li><li class=menu-item>
<a class=menu-item-link href=/categories/>Categories</a>
</li>
</ul>
</nav>
</header>
<main id=main class=main>
<div class=content-wrapper>
<div id=content class=content>
<article class=post>
<div class=post-content>
<h1 id=arraydeque>ArrayDeque</h1>
<p>Deque接口的大小可变数组的实现。</p>
<p>特性：</p>
<ul>
<li>底层实现：循环数组</li>
<li>没有容量限制，在数组元素装满时自动扩容</li>
<li>禁止插入null元素</li>
<li>作为Stack和Queue时比LinkedList实现更好（前提是减少频繁的扩容和remove数组移动操作）</li>
<li>不是线程安全的</li>
</ul>
<h2 id=类结构>类结构</h2>
<p><img src=../../../assets/images/c4f7b8de-1d5b-4f46-809d-6135b3d337f6.png alt></p>
<h3 id=构造器>构造器</h3>
<p>默认的ArrayDeque构造器创建的数组长度为16，而ArrayDeque能创建的最小数组长度即为16</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=c1>// 存储元素数组大小是2的幂  
</span><span class=c1></span><span class=kd>transient</span> <span class=n>Object</span><span class=o>[]</span> <span class=n>elements</span><span class=o>;</span>
<span class=cm>/**
</span><span class=cm> * Constructs an empty array deque with an initial capacity
</span><span class=cm> * sufficient to hold 16 elements.
</span><span class=cm> */</span>
<span class=kd>public</span> <span class=nf>ArrayDeque</span><span class=o>()</span> <span class=o>{</span>
    <span class=n>elements</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Object</span><span class=o>[</span><span class=n>16</span><span class=o>];</span>
<span class=o>}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id=数据结构循环数组>数据结构：循环数组</h2>
<p>循环数组通过保持数组头部head和尾部tail两个元素指针按对应的插入顺序访问元素。类似与链表的访问，java相关字段</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=c1>// head指针指向当前元素并插入时由后向前移动
</span><span class=c1></span><span class=kd>transient</span> <span class=kt>int</span> <span class=n>head</span><span class=o>;</span>

<span class=c1>// tail指针指向下个添加元素的位置。插入由前往后
</span><span class=c1></span><span class=kd>transient</span> <span class=kt>int</span> <span class=n>tail</span><span class=o>;</span>
</code></pre></td></tr></table>
</div>
</div><h3 id=指针位置>指针位置</h3>
<h4 id=关系>关系</h4>
<p>在ArrayDeque为空时有<code>head == tail</code>：</p>
<ul>
<li>初始状态：<code>head==tail==0</code></li>
<li>删除所有元素时：<code>head==tail</code>，可能在任何位置不一定在0</li>
</ul>
<p>当ArrayDeque一定存在元素：</p>
<ul>
<li>head != tail时（在add时可能有短暂的head==tail触发扩容操作）</li>
</ul>
<p>head指针指向最近插入的head元素。tail指针指向下一个插入的tail元素位置即指向null，在addX插入扩容时短暂与head相等而不指向null。</p>
<p>即在 <em>插入时</em> head需要向前移动一位插入新元素并置为head-1。tail直接插入当前位置并指向下一个空位置</p>
<h4 id=移动>移动</h4>
<p>以head为例，当head在插入时向后移动，初始化时<code>head=0</code>，插入一个元素<code>head-1=-1</code>，不可为数组索引；删除时当<code>head=data.length-1</code>，删除最后元素<code>head+1=data.length</code>，不可索引。</p>
<p>通常的方式是对head取余如：</p>
<ul>
<li><code>(this.head + 1) % this.data.length</code>插入head向前移动</li>
<li><code>(this.head - 1 + this.data.length) % this.data.length</code>删除head向后移动</li>
</ul>
<p>但是取余%这样频繁操作可能会影响性能，ArrayDeque用分配2^n位操作
<a test="isHyperLink=false" href=#%e5%88%86%e9%85%8d%e7%a9%ba%e9%97%b4>分配空间</a>的方式优化了性能</p>
<h4 id=插入>插入</h4>
<p>在插入时必定tail &lt;= head，在扩容后<code>head &lt; tail</code>，插入时head后移，有<code>tail &lt; head</code></p>
<h4 id=删除>删除</h4>
<p>删除时tail和head的位置大小无法确定，哪一种都有可能，最终都是tail左移<code>&lt;--</code>，head右移<code>--></code></p>
<ol>
<li><code>tail &lt; head</code>：指针head或tail都没有过界，head仍然在尾部，tail在头部</li>
<li><code>tail > head</code>：指针head或tail有一个过界，head可能删除到了头部，或tail删除到了尾部。不存在同时过界</li>
<li><code>tail == head</code>：所有元素全部删除完时tail == head，此时指针可能在数组任何位置</li>
</ol>
<p>典型的指针位置图示：</p>
<p><img src=../../../assets/images/07e4cd7d-755d-40ab-8870-71c000f0d6e3.png alt></p>
<h3 id=插入-1>插入</h3>
<p>初始化后，tail和head指针都指向数组下标0。</p>
<p>addFirst将元素插入数组尾部<code>(head-1) & length</code>，插入后head指向当前最近访问元素，插入时需要将head指针向前移动一位head-1。</p>
<p>addLast将元素插入到数组头部<code>tail & length</code>，插入后tail指向下一个插入位置<code>(tail + 1) & length</code>，插入时直接在tail位置插入，不需要移动。</p>
<p>插入图示：</p>
<p><img src=../../../assets/images/1d50a9d5-4697-4984-bbf0-623904d85e26.png alt></p>
<p>ArrayDeque的底层数组大小为2的次幂，这样可以使用位操作提高取余的速度</p>
<h4 id=取余操作>取余操作</h4>
<p>下面是使用8bit(最高位为符号位)进行addFirst的取余操作过程：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>head = (head - 1) &amp; (elements.length - 1)

head = 0		elements.length = 16	// 初始化时的设置
// 第一次插入
1111 1111		// (complement) head-1 =-1 
0000 1111	&amp;	// elements.length - 1=15
0000 1111		// -1 &amp; 15 = 15
// 第二次插入
0000 1110		// (complement) head(15)-1 = 14
0000 1111	&amp;	// elements.length - 1 = 15
0000 1110		// 14 &amp; 15 = 14
</code></pre></td></tr></table>
</div>
</div><h4 id=add源码>add源码</h4>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=cm>/**
</span><span class=cm> * Inserts the specified element at the front of this deque.
</span><span class=cm> *
</span><span class=cm> * @param e the element to add
</span><span class=cm> * @throws NullPointerException if the specified element is null
</span><span class=cm> */</span>
<span class=kd>public</span> <span class=kt>void</span> <span class=nf>addFirst</span><span class=o>(</span><span class=n>E</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>e</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
        <span class=k>throw</span> <span class=k>new</span> <span class=n>NullPointerException</span><span class=o>();</span>
    <span class=c1>// 对head指针取余，如head=0时，-1&amp;15=15,14&amp;15=14，将head指针从数组后面开始
</span><span class=c1></span>    <span class=c1>// 从head=e.length-1开始
</span><span class=c1></span>    <span class=n>elements</span><span class=o>[</span><span class=n>head</span> <span class=o>=</span> <span class=o>(</span><span class=n>head</span> <span class=o>-</span> <span class=n>1</span><span class=o>)</span> <span class=o>&amp;</span> <span class=o>(</span><span class=n>elements</span><span class=o>.</span><span class=na>length</span> <span class=o>-</span> <span class=n>1</span><span class=o>)]</span> <span class=o>=</span> <span class=n>e</span><span class=o>;</span>
    <span class=c1>// 扩容
</span><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>head</span> <span class=o>==</span> <span class=n>tail</span><span class=o>)</span>
        <span class=n>doubleCapacity</span><span class=o>();</span>
<span class=o>}</span>

<span class=cm>/**
</span><span class=cm> * Inserts the specified element at the end of this deque.
</span><span class=cm> *
</span><span class=cm> * &lt;p&gt;This method is equivalent to {@link #add}.
</span><span class=cm> *
</span><span class=cm> * @param e the element to add
</span><span class=cm> * @throws NullPointerException if the specified element is null
</span><span class=cm> */</span>
<span class=kd>public</span> <span class=kt>void</span> <span class=nf>addLast</span><span class=o>(</span><span class=n>E</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>e</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
        <span class=k>throw</span> <span class=k>new</span> <span class=n>NullPointerException</span><span class=o>();</span>
    <span class=c1>// 直接插入tail位置
</span><span class=c1></span>    <span class=n>elements</span><span class=o>[</span><span class=n>tail</span><span class=o>]</span> <span class=o>=</span> <span class=n>e</span><span class=o>;</span>
    <span class=c1>// 将tail只想后一个位置 判断tail == head就扩容
</span><span class=c1></span>    <span class=k>if</span> <span class=o>(</span> <span class=o>(</span><span class=n>tail</span> <span class=o>=</span> <span class=o>(</span><span class=n>tail</span> <span class=o>+</span> <span class=n>1</span><span class=o>)</span> <span class=o>&amp;</span> <span class=o>(</span><span class=n>elements</span><span class=o>.</span><span class=na>length</span> <span class=o>-</span> <span class=n>1</span><span class=o>))</span> <span class=o>==</span> <span class=n>head</span><span class=o>)</span>
        <span class=n>doubleCapacity</span><span class=o>();</span>
<span class=o>}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id=扩容>扩容</h3>
<p>当<code>tail==head</code>时触发扩容操作。在插入数组最后一个空位时，相应指针会移动一位使得tail == head。</p>
<p>将数组容量扩大一倍，并将元素复制到新数组中。将 <em><strong>head部分移动到新数组前边</strong></em> ，<em><strong>tail部分移动到head部分后面</strong></em>，扩大新增的数组部分在最后面，这样保证head像新数组中由后往前<code>&lt;--</code>移动，tail指针由前往后<code>--></code>移动</p>
<p>扩容图示：</p>
<p><img src=../../../assets/images/59ae12c4-b36c-4d05-aab9-4580e0e53923.png alt></p>
<ul>
<li>
<p>ArrayDeque的扩容只有在<code>head==tail</code>时即插入数组最后一个空位置时执行扩容操作，使得数组扩大一倍。</p>
</li>
<li>
<p>扩容后的新数组与初始化时一样，head指针由后往前，tail指针由原length位置往后</p>
</li>
<li>
<p>ArrayDeque指定容量大小为2的次幂，如果不是2的次幂，会将指定容量提高为当前最接近的2次幂</p>
</li>
<li>
<p>不应该指定容量为2的次幂，ArrayDeque仍然会扩大一次2的次幂，会增大一倍容量，如果已经考虑过最大容量，那么这样的设置将会增大一倍的空间浪费</p>
</li>
</ul>
<h4 id=扩容源码doublecapacity>扩容源码doubleCapacity</h4>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=cm>/**
</span><span class=cm> * Doubles the capacity of this deque.  Call only when full, i.e.,
</span><span class=cm> * when head and tail have wrapped around to become equal.
</span><span class=cm> */</span>
<span class=c1>// 仅当数组装满元素才扩大一倍
</span><span class=c1></span><span class=kd>private</span> <span class=kt>void</span> <span class=nf>doubleCapacity</span><span class=o>()</span> <span class=o>{</span>
    <span class=c1>// 检查只有head与tail相等时才允许扩容
</span><span class=c1></span>    <span class=k>assert</span> <span class=n>head</span> <span class=o>==</span> <span class=n>tail</span><span class=o>;</span>
    <span class=kt>int</span> <span class=n>p</span> <span class=o>=</span> <span class=n>head</span><span class=o>;</span>
    <span class=kt>int</span> <span class=n>n</span> <span class=o>=</span> <span class=n>elements</span><span class=o>.</span><span class=na>length</span><span class=o>;</span>
    <span class=c1>// p的右边的元素个数
</span><span class=c1></span>    <span class=kt>int</span> <span class=n>r</span> <span class=o>=</span> <span class=n>n</span> <span class=o>-</span> <span class=n>p</span><span class=o>;</span> <span class=c1>// number of elements to the right of p
</span><span class=c1></span>    <span class=c1>// 容量扩大一倍
</span><span class=c1></span>    <span class=kt>int</span> <span class=n>newCapacity</span> <span class=o>=</span> <span class=n>n</span> <span class=o>&lt;&lt;</span> <span class=n>1</span><span class=o>;</span>
    <span class=c1>// 2&lt;&lt;31溢出
</span><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>newCapacity</span> <span class=o>&lt;</span> <span class=n>0</span><span class=o>)</span>
        <span class=k>throw</span> <span class=k>new</span> <span class=n>IllegalStateException</span><span class=o>(</span><span class=s>&#34;Sorry, deque too big&#34;</span><span class=o>);</span>
    <span class=n>Object</span><span class=o>[]</span> <span class=n>a</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Object</span><span class=o>[</span><span class=n>newCapacity</span><span class=o>];</span>
    <span class=c1>// 右边head开始到原数组最后r个元素复制到新数组0开始到r-1
</span><span class=c1></span>    <span class=n>System</span><span class=o>.</span><span class=na>arraycopy</span><span class=o>(</span><span class=n>elements</span><span class=o>,</span> <span class=n>p</span><span class=o>,</span> <span class=n>a</span><span class=o>,</span> <span class=n>0</span><span class=o>,</span> <span class=n>r</span><span class=o>);</span>
    <span class=c1>// head左边的从0开始p个元素赋值到新数组从r开始到最后
</span><span class=c1></span>    <span class=n>System</span><span class=o>.</span><span class=na>arraycopy</span><span class=o>(</span><span class=n>elements</span><span class=o>,</span> <span class=n>0</span><span class=o>,</span> <span class=n>a</span><span class=o>,</span> <span class=n>r</span><span class=o>,</span> <span class=n>p</span><span class=o>);</span>
    <span class=n>elements</span> <span class=o>=</span> <span class=n>a</span><span class=o>;</span>
    <span class=n>head</span> <span class=o>=</span> <span class=n>0</span><span class=o>;</span>
    <span class=n>tail</span> <span class=o>=</span> <span class=n>n</span><span class=o>;</span>
<span class=o>}</span>

<span class=kd>public</span> <span class=kt>void</span> <span class=nf>addFirst</span><span class=o>(</span><span class=n>E</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>e</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
        <span class=k>throw</span> <span class=k>new</span> <span class=n>NullPointerException</span><span class=o>();</span>
    <span class=c1>// 对head指针取余，如head=0时，-1&amp;15=15,14&amp;15=14，将head指针从数组后面开始
</span><span class=c1></span>    <span class=c1>// 从head=e.length-1开始
</span><span class=c1></span>    <span class=n>elements</span><span class=o>[</span><span class=n>head</span> <span class=o>=</span> <span class=o>(</span><span class=n>head</span> <span class=o>-</span> <span class=n>1</span><span class=o>)</span> <span class=o>&amp;</span> <span class=o>(</span><span class=n>elements</span><span class=o>.</span><span class=na>length</span> <span class=o>-</span> <span class=n>1</span><span class=o>)]</span> <span class=o>=</span> <span class=n>e</span><span class=o>;</span>
    <span class=c1>// 扩容
</span><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>head</span> <span class=o>==</span> <span class=n>tail</span><span class=o>)</span>
        <span class=n>doubleCapacity</span><span class=o>();</span>
<span class=o>}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id=分配空间>分配空间</h3>
<p>allocateElements使用位操作将指定元素数量置为刚好大于该数量的2的次幂，下面是使用8bit模拟上面的过程</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>0100 1010		// numElements=74

0100 1010 
0010 0101	|	=&gt;	0110 1111	//	&gt;&gt;&gt;1

0110 1111
0001 1011	|	=&gt; 	0111 1111	// 	&gt;&gt;&gt;2

0111 1111
0000 0111 	| 	=&gt; 	0111 1111	//	&gt;&gt;&gt;4

0111 1111	+1	=&gt; 	1000 0000	// initialCapacity=128
</code></pre></td></tr></table>
</div>
</div><h4 id=capacity2n模拟分配过程><code>capacity=2^n</code>模拟分配过程</h4>
<p>如果使用2的次幂指定ArrayDeque的大小仍然会将增大一倍。如指定为<code>new ArrayDeque&lt;>(16)</code> ==> elements.length=32 即等价与<code>new ArrayDeque&lt;>(31)</code></p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=c1>// 在源代码包中创建才能调用private elements[]
</span><span class=c1></span><span class=kd>static</span> <span class=kt>void</span> <span class=nf>deleteTest</span><span class=o>()</span> <span class=o>{</span>
    <span class=n>ArrayDeque</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>deque</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayDeque</span><span class=o>&lt;&gt;(</span><span class=n>8</span><span class=o>);</span>
    <span class=n>deque</span><span class=o>.</span><span class=na>addFirst</span><span class=o>(</span><span class=s>&#34;d&#34;</span><span class=o>);</span>
    <span class=n>deque</span><span class=o>.</span><span class=na>addFirst</span><span class=o>(</span><span class=s>&#34;e&#34;</span><span class=o>);</span>
    
    <span class=n>deque</span><span class=o>.</span><span class=na>addLast</span><span class=o>(</span><span class=s>&#34;a&#34;</span><span class=o>);</span>
    <span class=n>deque</span><span class=o>.</span><span class=na>addLast</span><span class=o>(</span><span class=s>&#34;r&#34;</span><span class=o>);</span>
    <span class=n>deque</span><span class=o>.</span><span class=na>addLast</span><span class=o>(</span><span class=s>&#34;r&#34;</span><span class=o>);</span>
    <span class=n>deque</span><span class=o>.</span><span class=na>addLast</span><span class=o>(</span><span class=s>&#34;a&#34;</span><span class=o>);</span>
    <span class=n>deque</span><span class=o>.</span><span class=na>addLast</span><span class=o>(</span><span class=s>&#34;y&#34;</span><span class=o>);</span>
    <span class=c1>// 输出：elements.length=16
</span><span class=c1></span>    <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;elements.length=&#34;</span> <span class=o>+</span> <span class=n>deque</span><span class=o>.</span><span class=na>elements</span><span class=o>.</span><span class=na>length</span><span class=o>);</span>
    <span class=c1>// 输出：[a, r, r, a, y, null, null, null, null, null, null, null, null, null, e, d]
</span><span class=c1></span>    <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>Arrays</span><span class=o>.</span><span class=na>toString</span><span class=o>(</span><span class=n>deque</span><span class=o>.</span><span class=na>elements</span><span class=o>));</span>
<span class=o>}</span>
</code></pre></td></tr></table>
</div>
</div><p>下面以指定大小参数为8分配后容量为16的过程：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>numElements=8		initialCapacity=8	// 

0000 1000
0000 0100	|	=&gt;	0000 1100	// &gt;&gt;&gt;1

0000 1100
0000 0011	|	=&gt;	0000 1111	// &gt;&gt;&gt;2

0000 1111
0000 0000 	|	=&gt;	0000 1111	// &gt;&gt;&gt;4

0000 1111	+1	=&gt; 	0001 0000	// initialCapacity=16
</code></pre></td></tr></table>
</div>
</div><h4 id=分配空间源码allocateelements>分配空间源码allocateElements</h4>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=cm>/**
</span><span class=cm> * Allocates empty array to hold the given number of elements.
</span><span class=cm> *
</span><span class=cm> * @param numElements  the number of elements to hold
</span><span class=cm> */</span>
<span class=c1>// 将指定数量numElements置为接近2^n如：numElements=56 被置为64.
</span><span class=c1></span><span class=kd>private</span> <span class=kt>void</span> <span class=nf>allocateElements</span><span class=o>(</span><span class=kt>int</span> <span class=n>numElements</span><span class=o>)</span> <span class=o>{</span>
    <span class=c1>// 默认数组最小长度为8
</span><span class=c1></span>    <span class=kt>int</span> <span class=n>initialCapacity</span> <span class=o>=</span> <span class=n>MIN_INITIAL_CAPACITY</span><span class=o>;</span>
    <span class=c1>// Find the best power of two to hold elements.
</span><span class=c1></span>    <span class=c1>// Tests &#34;&lt;=&#34; because arrays aren&#39;t kept full.
</span><span class=c1></span>    <span class=c1>// 如果是1&lt;&lt;30传入进来，最后所有30位都是1，++后就为2&lt;&lt;31溢出，溢出就取最大值2&lt;&lt;30
</span><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>numElements</span> <span class=o>&gt;=</span> <span class=n>initialCapacity</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>initialCapacity</span> <span class=o>=</span> <span class=n>numElements</span><span class=o>;</span>
        <span class=n>initialCapacity</span> <span class=o>|=</span> <span class=o>(</span><span class=n>initialCapacity</span> <span class=o>&gt;&gt;&gt;</span>  <span class=n>1</span><span class=o>);</span>
        <span class=n>initialCapacity</span> <span class=o>|=</span> <span class=o>(</span><span class=n>initialCapacity</span> <span class=o>&gt;&gt;&gt;</span>  <span class=n>2</span><span class=o>);</span>
        <span class=n>initialCapacity</span> <span class=o>|=</span> <span class=o>(</span><span class=n>initialCapacity</span> <span class=o>&gt;&gt;&gt;</span>  <span class=n>4</span><span class=o>);</span>
        <span class=n>initialCapacity</span> <span class=o>|=</span> <span class=o>(</span><span class=n>initialCapacity</span> <span class=o>&gt;&gt;&gt;</span>  <span class=n>8</span><span class=o>);</span>
        <span class=n>initialCapacity</span> <span class=o>|=</span> <span class=o>(</span><span class=n>initialCapacity</span> <span class=o>&gt;&gt;&gt;</span> <span class=n>16</span><span class=o>);</span>
        <span class=n>initialCapacity</span><span class=o>++;</span>
        <span class=c1>//溢出就取最大值2&lt;&lt;30
</span><span class=c1></span>        <span class=k>if</span> <span class=o>(</span><span class=n>initialCapacity</span> <span class=o>&lt;</span> <span class=n>0</span><span class=o>)</span>   <span class=c1>// Too many elements, must back off
</span><span class=c1></span>            <span class=n>initialCapacity</span> <span class=o>&gt;&gt;&gt;=</span> <span class=n>1</span><span class=o>;</span><span class=c1>// Good luck allocating 2 ^ 30 elements
</span><span class=c1></span>    <span class=o>}</span>
    <span class=n>elements</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Object</span><span class=o>[</span><span class=n>initialCapacity</span><span class=o>];</span>
<span class=o>}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id=删除-1>删除</h3>
<p>删除两端元素十分简单，这里解释循环数组中任意位置的删除</p>
<p>删除指定位置有2种情况，这里的同一端指都在循环数组的尾部或头部</p>
<ul>
<li>删除位置i更靠近head位置，根据删除位置i是否与head在同一端分为head &lt;= i（同端）和head > i（异端）</li>
<li>删除位置i更靠近tail位置，根据删除位置i是否与tail在同一端分为tail >= i（同端）和tail &lt; i（异端）</li>
</ul>
<p>下面以head与删除位置i的情况举例，tail的删除与head同理</p>
<p>注意：<strong>front &lt; back 表示删除位置i更接近head而不是tail</strong>，应该结合删除的源代码理解</p>
<h4 id=同端head--i>同端（head &lt;= i）</h4>
<p>同端即head和删除位置i在同一部分尾部或头部，此时只需要将 <em><strong>删除位置左边的头部元素右移覆盖删除位置</strong></em> 即可</p>
<p><img src=../../../assets/images/4455d5d1-b76b-4b32-93d9-c02d16893305.png alt></p>
<p>另一种形式仍然是同端的删除：</p>
<p><img src=../../../assets/images/bd55584d-c831-4a13-a702-aa235be7012f.png alt></p>
<h4 id=异端head--i>异端（head > i）</h4>
<p>异端即head与删除位置i分开在尾部和头部（顺序不定），由于head和删除位置i在数组前端和后端（顺序不定），删除该位置需要将 <em><strong>删除位置i前元素右移覆盖删除位置和将head部分右移一位</strong></em> 即可</p>
<ol>
<li>删除位置i前的所有元素右移一位覆盖删除位置i</li>
<li>将数组位置0使用head部分数组末位元素替换</li>
<li>移动head部分到数组末端并将head的元素置为null</li>
</ol>
<p><img src=../../../assets/images/e66f83f0-2232-4ad4-b223-5841017deb08.png alt></p>
<h4 id=delete源码>delete源码</h4>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=cm>/**
</span><span class=cm> * Removes the element at the specified position in the elements array,
</span><span class=cm> * adjusting head and tail as necessary.  This can result in motion of
</span><span class=cm> * elements backwards or forwards in the array.
</span><span class=cm> *
</span><span class=cm> * &lt;p&gt;This method is called delete rather than remove to emphasize
</span><span class=cm> * that its semantics differ from those of {@link List#remove(int)}.
</span><span class=cm> *
</span><span class=cm> * @return true if elements moved backwards
</span><span class=cm> */</span>
<span class=cm>/*
</span><span class=cm>* 删除指定位置的元素。如果指定位置元素为null即删除null时无论那种情况都不会报错，而且能够正常工作
</span><span class=cm>* 这个指定的null元素会被数组元素移动覆盖。
</span><span class=cm>* 注意！！该方法返回值不表示删除是否失败！！返回false表示右移覆盖删除，返回true表示左移覆盖删除
</span><span class=cm>*/</span>
<span class=kd>private</span> <span class=kt>boolean</span> <span class=nf>delete</span><span class=o>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>)</span> <span class=o>{</span>
    <span class=c1>// assert 检查
</span><span class=c1></span>    <span class=n>checkInvariants</span><span class=o>();</span>
    <span class=kd>final</span> <span class=n>Object</span><span class=o>[]</span> <span class=n>elements</span> <span class=o>=</span> <span class=k>this</span><span class=o>.</span><span class=na>elements</span><span class=o>;</span>
    <span class=kd>final</span> <span class=kt>int</span> <span class=n>mask</span> <span class=o>=</span> <span class=n>elements</span><span class=o>.</span><span class=na>length</span> <span class=o>-</span> <span class=n>1</span><span class=o>;</span>
    <span class=kd>final</span> <span class=kt>int</span> <span class=n>h</span> <span class=o>=</span> <span class=n>head</span><span class=o>;</span>
    <span class=kd>final</span> <span class=kt>int</span> <span class=n>t</span> <span class=o>=</span> <span class=n>tail</span><span class=o>;</span>
    <span class=c1>// 删除元素下标i与head间隔front个，如：h=10,i=12,2&amp;mask=2或h=8,i=2,t=3.-6&amp;mask=10
</span><span class=c1></span>    <span class=c1>// 注意tail往左&lt;--数组,head往右走--&gt;
</span><span class=c1></span>    <span class=kd>final</span> <span class=kt>int</span> <span class=n>front</span> <span class=o>=</span> <span class=o>(</span><span class=n>i</span> <span class=o>-</span> <span class=n>h</span><span class=o>)</span> <span class=o>&amp;</span> <span class=n>mask</span><span class=o>;</span>
    <span class=c1>// 下标i与tail间隔长度back如：h=8,i=2,t=3.1&amp;mask=1
</span><span class=c1></span>    <span class=kd>final</span> <span class=kt>int</span> <span class=n>back</span>  <span class=o>=</span> <span class=o>(</span><span class=n>t</span> <span class=o>-</span> <span class=n>i</span><span class=o>)</span> <span class=o>&amp;</span> <span class=n>mask</span><span class=o>;</span>

    <span class=c1>// Invariant: head &lt;= i &lt; tail mod circularity
</span><span class=c1></span>    <span class=c1>// t-h&amp;mask表示数组中含有这个多元素如16中t=3,h=8,共11个元素。3-8 &amp; 15 = 11
</span><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>front</span> <span class=o>&gt;=</span> <span class=o>((</span><span class=n>t</span> <span class=o>-</span> <span class=n>h</span><span class=o>)</span> <span class=o>&amp;</span> <span class=n>mask</span><span class=o>))</span>
        <span class=k>throw</span> <span class=k>new</span> <span class=n>ConcurrentModificationException</span><span class=o>();</span>

    <span class=c1>// Optimize for least element motion
</span><span class=c1></span>    <span class=c1>// 删除元素位置i更接近与head指针
</span><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>front</span> <span class=o>&lt;</span> <span class=n>back</span><span class=o>)</span> <span class=o>{</span>
        <span class=c1>// head和i在同一端  将[head...i-1]这些元素往后移动一位
</span><span class=c1></span>        <span class=k>if</span> <span class=o>(</span><span class=n>h</span> <span class=o>&lt;=</span> <span class=n>i</span><span class=o>)</span> <span class=o>{</span>
            <span class=n>System</span><span class=o>.</span><span class=na>arraycopy</span><span class=o>(</span><span class=n>elements</span><span class=o>,</span> <span class=n>h</span><span class=o>,</span> <span class=n>elements</span><span class=o>,</span> <span class=n>h</span> <span class=o>+</span> <span class=n>1</span><span class=o>,</span> <span class=n>front</span><span class=o>);</span>
        <span class=o>}</span> 
        <span class=c1>// head和i不在同一端，需要移动i之前的元素后再移动head端的元素
</span><span class=c1></span>        <span class=k>else</span> <span class=o>{</span> <span class=c1>// Wrap around
</span><span class=c1></span>            <span class=c1>// 删除位置i前的所有元素右移一位覆盖i
</span><span class=c1></span>            <span class=n>System</span><span class=o>.</span><span class=na>arraycopy</span><span class=o>(</span><span class=n>elements</span><span class=o>,</span> <span class=n>0</span><span class=o>,</span> <span class=n>elements</span><span class=o>,</span> <span class=n>1</span><span class=o>,</span> <span class=n>i</span><span class=o>);</span>
            <span class=c1>// 数组末位元素替换移动后的重复索引1位置的索引0的元素
</span><span class=c1></span>            <span class=n>elements</span><span class=o>[</span><span class=n>0</span><span class=o>]</span> <span class=o>=</span> <span class=n>elements</span><span class=o>[</span><span class=n>mask</span><span class=o>];</span>
            <span class=c1>// 移动head部分即数组head到末端右移一位 
</span><span class=c1></span>            <span class=n>System</span><span class=o>.</span><span class=na>arraycopy</span><span class=o>(</span><span class=n>elements</span><span class=o>,</span> <span class=n>h</span><span class=o>,</span> <span class=n>elements</span><span class=o>,</span> <span class=n>h</span> <span class=o>+</span> <span class=n>1</span><span class=o>,</span> <span class=n>mask</span> <span class=o>-</span> <span class=n>h</span><span class=o>);</span>
        <span class=o>}</span>
        <span class=c1>// 将移动后的head位置元素删除
</span><span class=c1></span>        <span class=n>elements</span><span class=o>[</span><span class=n>h</span><span class=o>]</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
        <span class=c1>// 更新head位置
</span><span class=c1></span>        <span class=n>head</span> <span class=o>=</span> <span class=o>(</span><span class=n>h</span> <span class=o>+</span> <span class=n>1</span><span class=o>)</span> <span class=o>&amp;</span> <span class=n>mask</span><span class=o>;</span>
        <span class=c1>// 注意！！！这个false不是表示删除失败，而是表示通过右移覆盖删除
</span><span class=c1></span>        <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
    <span class=o>}</span> 
    <span class=c1>// 删除位置更接近tail位置
</span><span class=c1></span>    <span class=k>else</span> <span class=o>{</span>
        <span class=c1>// 删除位置与tail在同一端
</span><span class=c1></span>        <span class=k>if</span> <span class=o>(</span><span class=n>i</span> <span class=o>&lt;</span> <span class=n>t</span><span class=o>)</span> <span class=o>{</span> <span class=c1>// Copy the null tail as well
</span><span class=c1></span>            <span class=c1>// 将删除位置i后面的tial部分元素左移一位覆盖删除位置
</span><span class=c1></span>            <span class=n>System</span><span class=o>.</span><span class=na>arraycopy</span><span class=o>(</span><span class=n>elements</span><span class=o>,</span> <span class=n>i</span> <span class=o>+</span> <span class=n>1</span><span class=o>,</span> <span class=n>elements</span><span class=o>,</span> <span class=n>i</span><span class=o>,</span> <span class=n>back</span><span class=o>);</span>
            <span class=n>tail</span> <span class=o>=</span> <span class=n>t</span> <span class=o>-</span> <span class=n>1</span><span class=o>;</span>
        <span class=o>}</span> 
        <span class=c1>// 删除位置与tail不在同一端
</span><span class=c1></span>        <span class=k>else</span> <span class=o>{</span> <span class=c1>// Wrap around
</span><span class=c1></span>            <span class=n>System</span><span class=o>.</span><span class=na>arraycopy</span><span class=o>(</span><span class=n>elements</span><span class=o>,</span> <span class=n>i</span> <span class=o>+</span> <span class=n>1</span><span class=o>,</span> <span class=n>elements</span><span class=o>,</span> <span class=n>i</span><span class=o>,</span> <span class=n>mask</span> <span class=o>-</span> <span class=n>i</span><span class=o>);</span>
            <span class=n>elements</span><span class=o>[</span><span class=n>mask</span><span class=o>]</span> <span class=o>=</span> <span class=n>elements</span><span class=o>[</span><span class=n>0</span><span class=o>];</span>
            <span class=n>System</span><span class=o>.</span><span class=na>arraycopy</span><span class=o>(</span><span class=n>elements</span><span class=o>,</span> <span class=n>1</span><span class=o>,</span> <span class=n>elements</span><span class=o>,</span> <span class=n>0</span><span class=o>,</span> <span class=n>t</span><span class=o>);</span>
            <span class=n>tail</span> <span class=o>=</span> <span class=o>(</span><span class=n>t</span> <span class=o>-</span> <span class=n>1</span><span class=o>)</span> <span class=o>&amp;</span> <span class=n>mask</span><span class=o>;</span>
        <span class=o>}</span>
        <span class=c1>// 注意tail端不需要置tail位置为null，因为tail本为null,移动后用null覆盖前面的位置了
</span><span class=c1></span>        <span class=c1>// 注意！！！这个true不是表示删除成功，而是表示通过左移覆盖删除
</span><span class=c1></span>        <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
    <span class=o>}</span>
<span class=o>}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id=总结>总结</h4>
<p>在数组中 <em><strong>删除元素都是移动元素覆盖该位置</strong></em>。无论时同端还是异端都是将删除位置前的元素移动一位覆盖删除位置，只不过由于异端时移动不能连续而已</p>
<p>指定位置靠近head时通过右移覆盖删除，指定位置靠近tail时通过左移覆盖删除</p>
<h3 id=简单实现>简单实现</h3>
<p>
<a test="isHyperLink=true" href=https://leetcode-cn.com/problems/design-circular-deque/>641. 设计循环双端队列</a></p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span><span class=lnt>77
</span><span class=lnt>78
</span><span class=lnt>79
</span><span class=lnt>80
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=kd>class</span> <span class=nc>MyCircularDeque</span> <span class=o>{</span>
    <span class=kd>private</span> <span class=kd>final</span> <span class=kt>int</span><span class=o>[]</span> <span class=n>data</span><span class=o>;</span>
    <span class=kd>private</span> <span class=kt>int</span> <span class=n>head</span><span class=o>;</span>
    <span class=kd>private</span> <span class=kt>int</span> <span class=n>tail</span><span class=o>;</span>

    <span class=cm>/** Initialize your data structure here. Set the size of the deque to be k. */</span>
    <span class=kd>public</span> <span class=nf>MyCircularDeque</span><span class=o>(</span><span class=kt>int</span> <span class=n>k</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>this</span><span class=o>.</span><span class=na>data</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=o>[</span><span class=n>k</span> <span class=o>+</span> <span class=n>1</span><span class=o>];</span>
        <span class=k>this</span><span class=o>.</span><span class=na>head</span> <span class=o>=</span> <span class=n>0</span><span class=o>;</span>
        <span class=k>this</span><span class=o>.</span><span class=na>tail</span> <span class=o>=</span> <span class=n>0</span><span class=o>;</span>
    <span class=o>}</span>

    <span class=cm>/** Adds an item at the front of Deque. Return true if the operation is successful. */</span>
    <span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>insertFront</span><span class=o>(</span><span class=kt>int</span> <span class=n>value</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>if</span> <span class=o>(</span><span class=k>this</span><span class=o>.</span><span class=na>isFull</span><span class=o>())</span> <span class=o>{</span>
            <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
        <span class=o>}</span>

        <span class=k>this</span><span class=o>.</span><span class=na>head</span> <span class=o>=</span> <span class=o>(</span><span class=k>this</span><span class=o>.</span><span class=na>head</span> <span class=o>-</span> <span class=n>1</span> <span class=o>+</span> <span class=k>this</span><span class=o>.</span><span class=na>data</span><span class=o>.</span><span class=na>length</span><span class=o>)</span> <span class=o>%</span> <span class=k>this</span><span class=o>.</span><span class=na>data</span><span class=o>.</span><span class=na>length</span><span class=o>;</span>
        <span class=k>this</span><span class=o>.</span><span class=na>data</span><span class=o>[</span><span class=k>this</span><span class=o>.</span><span class=na>head</span><span class=o>]</span> <span class=o>=</span> <span class=n>value</span><span class=o>;</span>
        <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
    <span class=o>}</span>

    <span class=cm>/** Adds an item at the rear of Deque. Return true if the operation is successful. */</span>
    <span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>insertLast</span><span class=o>(</span><span class=kt>int</span> <span class=n>value</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>if</span> <span class=o>(</span><span class=k>this</span><span class=o>.</span><span class=na>isFull</span><span class=o>())</span> <span class=o>{</span>
            <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
        <span class=o>}</span>
        <span class=k>this</span><span class=o>.</span><span class=na>data</span><span class=o>[</span><span class=k>this</span><span class=o>.</span><span class=na>tail</span><span class=o>]</span> <span class=o>=</span> <span class=n>value</span><span class=o>;</span>
        <span class=k>this</span><span class=o>.</span><span class=na>tail</span> <span class=o>=</span> <span class=o>(</span><span class=k>this</span><span class=o>.</span><span class=na>tail</span> <span class=o>+</span> <span class=n>1</span><span class=o>)</span> <span class=o>%</span> <span class=n>data</span><span class=o>.</span><span class=na>length</span><span class=o>;</span>
        <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
    <span class=o>}</span>

    <span class=cm>/** Deletes an item from the front of Deque. Return true if the operation is successful. 
</span><span class=cm>    public boolean deleteFront() {
</span><span class=cm>        if (this.isEmpty()) {
</span><span class=cm>            return false;
</span><span class=cm>        }
</span><span class=cm>        this.data[this.head] = -1;
</span><span class=cm>        this.head = (this.head + 1) % this.data.length;
</span><span class=cm>        return true;
</span><span class=cm>    }
</span><span class=cm>
</span><span class=cm>    /** Deletes an item from the rear of Deque. Return true if the operation is successful. */</span>
    <span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>deleteLast</span><span class=o>()</span> <span class=o>{</span>
        <span class=k>if</span> <span class=o>(</span><span class=k>this</span><span class=o>.</span><span class=na>isEmpty</span><span class=o>())</span> <span class=o>{</span>
            <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
        <span class=o>}</span>
        <span class=k>this</span><span class=o>.</span><span class=na>tail</span> <span class=o>=</span> <span class=o>(</span><span class=k>this</span><span class=o>.</span><span class=na>tail</span> <span class=o>-</span> <span class=n>1</span> <span class=o>+</span> <span class=k>this</span><span class=o>.</span><span class=na>data</span><span class=o>.</span><span class=na>length</span><span class=o>)</span> <span class=o>%</span> <span class=k>this</span><span class=o>.</span><span class=na>data</span><span class=o>.</span><span class=na>length</span><span class=o>;</span>
        <span class=k>this</span><span class=o>.</span><span class=na>data</span><span class=o>[</span><span class=k>this</span><span class=o>.</span><span class=na>tail</span><span class=o>]</span> <span class=o>=</span> <span class=o>-</span><span class=n>1</span><span class=o>;</span>
        <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
    <span class=o>}</span>

    <span class=cm>/** Get the front item from the deque. */</span>
    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>getFront</span><span class=o>()</span> <span class=o>{</span>
        <span class=k>if</span> <span class=o>(</span><span class=k>this</span><span class=o>.</span><span class=na>isEmpty</span><span class=o>())</span> <span class=o>{</span>
            <span class=k>return</span> <span class=o>-</span><span class=n>1</span><span class=o>;</span>
        <span class=o>}</span>
        <span class=k>return</span> <span class=k>this</span><span class=o>.</span><span class=na>data</span><span class=o>[</span><span class=k>this</span><span class=o>.</span><span class=na>head</span><span class=o>];</span>
    <span class=o>}</span>

    <span class=cm>/** Get the last item from the deque. */</span>
    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>getRear</span><span class=o>()</span> <span class=o>{</span>
        <span class=k>if</span> <span class=o>(</span><span class=k>this</span><span class=o>.</span><span class=na>isEmpty</span><span class=o>())</span> <span class=o>{</span>
            <span class=k>return</span> <span class=o>-</span><span class=n>1</span><span class=o>;</span>
        <span class=o>}</span>
        <span class=k>return</span> <span class=k>this</span><span class=o>.</span><span class=na>data</span><span class=o>[(</span><span class=k>this</span><span class=o>.</span><span class=na>tail</span> <span class=o>-</span> <span class=n>1</span> <span class=o>+</span> <span class=k>this</span><span class=o>.</span><span class=na>data</span><span class=o>.</span><span class=na>length</span><span class=o>)</span> <span class=o>%</span> <span class=k>this</span><span class=o>.</span><span class=na>data</span><span class=o>.</span><span class=na>length</span><span class=o>];</span>
    <span class=o>}</span>

    <span class=cm>/** Checks whether the circular deque is empty or not. */</span>
    <span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>isEmpty</span><span class=o>()</span> <span class=o>{</span>
        <span class=k>return</span> <span class=k>this</span><span class=o>.</span><span class=na>head</span> <span class=o>==</span> <span class=k>this</span><span class=o>.</span><span class=na>tail</span><span class=o>;</span>
    <span class=o>}</span>

    <span class=cm>/** Checks whether the circular deque is full or not. */</span>
    <span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>isFull</span><span class=o>()</span> <span class=o>{</span>
        <span class=k>return</span> <span class=k>this</span><span class=o>.</span><span class=na>head</span> <span class=o>==</span> <span class=o>(</span><span class=k>this</span><span class=o>.</span><span class=na>tail</span> <span class=o>+</span> <span class=n>1</span><span class=o>)</span> <span class=o>%</span> <span class=k>this</span><span class=o>.</span><span class=na>data</span><span class=o>.</span><span class=na>length</span><span class=o>;</span>
    <span class=o>}</span>

<span class=o>}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id=队列queue与堆栈stack>队列Queue与堆栈Stack</h2>
<h3 id=插入-2>插入</h3>
<p>与LinkedList一样属于无界队列，不存在因为容量限制而添加失败，所以addX和offerX系列的方法本质都是一样的，但是作为queue使用时仍然应该区分这两种形式的api。</p>
<p>offer和add底层调用为addLast(E e)，但是在这两个方法中一个前者可以返回false(实际仍然不可offerLast)，后者返回固定值true。在需要使用true/false验证时可以使用推荐offer方法</p>
<h3 id=删除-2>删除</h3>
<p>remove和poll方法在队列为空时前者抛出异常而后者返回null。底层实现均调用pollFirst()，区别在于前者判断为null时抛出异常而后者返回null</p>
<h3 id=检查>检查</h3>
<p>element和peek方法底层实现都是返回head指针位置的数组元素，区别在于当队列为空时前者抛出异常而后者返回null</p>
<h3 id=总结-1>总结</h3>
<p><em><strong>将ArrayDeque作为队列实现比LinkedList更好，因为其禁止插入null和有更好的性能</strong></em></p>
<p>链表在访问时不容易缓存命中，且需要更大的内存，作为队列唯一的好处是在迭代时更容易删除。</p>
<p>ArrayDeque作为队列针对与数组两端add/remove操作时要快于LinkedList，而且数组访问速度更快</p>
<p>但是，ArrayDeque在删除时需要移动复制数组，所以尽量避免在迭代中删除数组元素。另外需要减少在add时扩容操作，所以在创建ArrayDeque时应该指定容量</p>
<p>参考：
<a test="isHyperLink=true" href=https://stackoverflow.com/a/6163204>Why is ArrayDeque better than LinkedList</a></p>
<h2 id=双端队列deque>双端队列Deque</h2>
<h3 id=插入-3>插入</h3>
<ul>
<li>addX和offerX在存在容量限制时插入失败前者抛出异常，后者返回false。但ArrayDeque不存在容量限制因此两者并无本质区别</li>
<li>addFirst与addLast在插入时使用位操作代替取余操作提高速度</li>
<li>所有的插入方法都不允许插入null元素，否则抛出异常</li>
<li>head指针指向最近插入头部的元素，tail指针指向最近插入尾部元素的下一个空位置</li>
</ul>
<h3 id=删除-3>删除</h3>
<ul>
<li>removeX和pollX方法都是移除双端元素，底层方法也一致，区别在于当队列为空时前者抛出异常，后者返回null。</li>
<li>双端队列Deque是对两端元素的移除，不会对队列中的元素移除，所以不需要进行数组元素移动的操作</li>
</ul>
<h3 id=检查-1>检查</h3>
<ul>
<li>getX和peekX方法都是返回两端元素，底层均为读取数组元素，区别在于当队列为空时前者抛出异常，后者返回null</li>
<li>First使用head指针，读取时head指针指向头部元素，Last使用tail指针，读取时需要往前移动到尾部元素</li>
</ul>
<h3 id=移除>移除</h3>
<ul>
<li>数组的移除需要移动数组元素，代价高昂</li>
<li>clear()操作仍然保留底层数组，而且只在head&ndash;tail之中移除已设置的元素为null，不用遍历完整的数组</li>
</ul>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=cm>/**
</span><span class=cm> * Removes all of the elements from this deque.
</span><span class=cm> * The deque will be empty after this call returns.
</span><span class=cm> */</span>
<span class=kd>public</span> <span class=kt>void</span> <span class=nf>clear</span><span class=o>()</span> <span class=o>{</span>
    <span class=kt>int</span> <span class=n>h</span> <span class=o>=</span> <span class=n>head</span><span class=o>;</span>
    <span class=kt>int</span> <span class=n>t</span> <span class=o>=</span> <span class=n>tail</span><span class=o>;</span>
    <span class=c1>// 验证当前ArrayDeque是否为空  
</span><span class=c1></span>    <span class=c1>// 注意如果arraydeque不为空则head!=tail成立(在add时可能短暂的相等)
</span><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>h</span> <span class=o>!=</span> <span class=n>t</span><span class=o>)</span> <span class=o>{</span> <span class=c1>// clear all cells
</span><span class=c1></span>        <span class=n>head</span> <span class=o>=</span> <span class=n>tail</span> <span class=o>=</span> <span class=n>0</span><span class=o>;</span>
        <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>h</span><span class=o>;</span>
        <span class=kt>int</span> <span class=n>mask</span> <span class=o>=</span> <span class=n>elements</span><span class=o>.</span><span class=na>length</span> <span class=o>-</span> <span class=n>1</span><span class=o>;</span>
        <span class=c1>// 按照head--tail指针遍历移除元素  避免遍历整个数组
</span><span class=c1></span>        <span class=k>do</span> <span class=o>{</span>
            <span class=n>elements</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
            <span class=n>i</span> <span class=o>=</span> <span class=o>(</span><span class=n>i</span> <span class=o>+</span> <span class=n>1</span><span class=o>)</span> <span class=o>&amp;</span> <span class=n>mask</span><span class=o>;</span>
        <span class=o>}</span> <span class=k>while</span> <span class=o>(</span><span class=n>i</span> <span class=o>!=</span> <span class=n>t</span><span class=o>);</span>
    <span class=o>}</span>
<span class=o>}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id=迭代器>迭代器</h3>
<ul>
<li>循环数组的迭代有点类似与链表迭代，都是从head开始都tail结束，不同是循环数组的下一个元素需要用取余操作实现。</li>
<li>循环数组与链表在迭代的唯一劣势就是remove()，因为数组删除元素需要移动数组元素。在循环数组中还需要考虑左移开始右移来判断下一个位置元素是否被替换，左移被替换后需要更新当前cursor为cursor-1</li>
</ul>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=kd>private</span> <span class=kd>class</span> <span class=nc>DeqIterator</span> <span class=kd>implements</span> <span class=n>Iterator</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=o>{</span>
    <span class=cm>/**
</span><span class=cm>     * Index of element to be returned by subsequent call to next.
</span><span class=cm>     */</span>
    <span class=kd>private</span> <span class=kt>int</span> <span class=n>cursor</span> <span class=o>=</span> <span class=n>head</span><span class=o>;</span>

    <span class=cm>/**
</span><span class=cm>     * Tail recorded at construction (also in remove), to stop
</span><span class=cm>     * iterator and also to check for comodification.
</span><span class=cm>     */</span>
    <span class=c1>// 用于迭代完成检查和结构修改检查
</span><span class=c1></span>    <span class=kd>private</span> <span class=kt>int</span> <span class=n>fence</span> <span class=o>=</span> <span class=n>tail</span><span class=o>;</span>

    <span class=cm>/**
</span><span class=cm>     * Index of element returned by most recent call to next.
</span><span class=cm>     * Reset to -1 if element is deleted by a call to remove.
</span><span class=cm>     */</span>
    <span class=kd>private</span> <span class=kt>int</span> <span class=n>lastRet</span> <span class=o>=</span> <span class=o>-</span><span class=n>1</span><span class=o>;</span>

    <span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>hasNext</span><span class=o>()</span> <span class=o>{</span> 
        <span class=c1>// 是否迭代到tail位置 即完成迭代
</span><span class=c1></span>        <span class=k>return</span> <span class=n>cursor</span> <span class=o>!=</span> <span class=n>fence</span><span class=o>;</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=n>E</span> <span class=nf>next</span><span class=o>()</span> <span class=o>{</span>
        <span class=c1>// 迭代完成 没有元素了
</span><span class=c1></span>        <span class=k>if</span> <span class=o>(</span><span class=n>cursor</span> <span class=o>==</span> <span class=n>fence</span><span class=o>)</span>
            <span class=k>throw</span> <span class=k>new</span> <span class=n>NoSuchElementException</span><span class=o>();</span>
        <span class=nd>@SuppressWarnings</span><span class=o>(</span><span class=s>&#34;unchecked&#34;</span><span class=o>)</span>
        <span class=n>E</span> <span class=n>result</span> <span class=o>=</span> <span class=o>(</span><span class=n>E</span><span class=o>)</span> <span class=n>elements</span><span class=o>[</span><span class=n>cursor</span><span class=o>];</span>
        <span class=c1>// This check doesn&#39;t catch all possible comodifications,
</span><span class=c1></span>        <span class=c1>// but does catch the ones that corrupt traversal
</span><span class=c1></span>        <span class=c1>// 如果有其他线程修改了结构  仅能保证正确的遍历
</span><span class=c1></span>        <span class=k>if</span> <span class=o>(</span><span class=n>tail</span> <span class=o>!=</span> <span class=n>fence</span> <span class=o>||</span> <span class=n>result</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
            <span class=k>throw</span> <span class=k>new</span> <span class=n>ConcurrentModificationException</span><span class=o>();</span>
        <span class=n>lastRet</span> <span class=o>=</span> <span class=n>cursor</span><span class=o>;</span>
        <span class=c1>// 下一个元素位置
</span><span class=c1></span>        <span class=n>cursor</span> <span class=o>=</span> <span class=o>(</span><span class=n>cursor</span> <span class=o>+</span> <span class=n>1</span><span class=o>)</span> <span class=o>&amp;</span> <span class=o>(</span><span class=n>elements</span><span class=o>.</span><span class=na>length</span> <span class=o>-</span> <span class=n>1</span><span class=o>);</span>
        <span class=k>return</span> <span class=n>result</span><span class=o>;</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>remove</span><span class=o>()</span> <span class=o>{</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>lastRet</span> <span class=o>&lt;</span> <span class=n>0</span><span class=o>)</span> 
            <span class=k>throw</span> <span class=k>new</span> <span class=n>IllegalStateException</span><span class=o>();</span>
        <span class=c1>// 如果是左移 导致下一个元素移动到删除位置lastRet即cursor-1上，类似与删除数组上一个元素，需要将当前cursor-1使在next能够读取到
</span><span class=c1></span>        <span class=k>if</span> <span class=o>(</span><span class=n>delete</span><span class=o>(</span><span class=n>lastRet</span><span class=o>))</span> <span class=o>{</span> <span class=c1>// if left-shifted, undo increment in next()
</span><span class=c1></span>            <span class=c1>// 设置为上一个位置 原cursor表示的元素被移动到cursor-1位置了
</span><span class=c1></span>            <span class=n>cursor</span> <span class=o>=</span> <span class=o>(</span><span class=n>cursor</span> <span class=o>-</span> <span class=n>1</span><span class=o>)</span> <span class=o>&amp;</span> <span class=o>(</span><span class=n>elements</span><span class=o>.</span><span class=na>length</span> <span class=o>-</span> <span class=n>1</span><span class=o>);</span>
            <span class=c1>// tail被改变 -1
</span><span class=c1></span>            <span class=n>fence</span> <span class=o>=</span> <span class=n>tail</span><span class=o>;</span>
        <span class=o>}</span><span class=c1>// 如果时右移 不会影响当前cursor位置上的元素，类似删除数组下一个元素，保持当前cursor  虽然head改变了 但是不影响cursor继续遍历
</span><span class=c1></span>        <span class=n>lastRet</span> <span class=o>=</span> <span class=o>-</span><span class=n>1</span><span class=o>;</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>forEachRemaining</span><span class=o>(</span><span class=n>Consumer</span><span class=o>&lt;?</span> <span class=kd>super</span> <span class=n>E</span><span class=o>&gt;</span> <span class=n>action</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>Objects</span><span class=o>.</span><span class=na>requireNonNull</span><span class=o>(</span><span class=n>action</span><span class=o>);</span>
        <span class=n>Object</span><span class=o>[]</span> <span class=n>a</span> <span class=o>=</span> <span class=n>elements</span><span class=o>;</span>
        <span class=kt>int</span> <span class=n>m</span> <span class=o>=</span> <span class=n>a</span><span class=o>.</span><span class=na>length</span> <span class=o>-</span> <span class=n>1</span><span class=o>,</span> <span class=n>f</span> <span class=o>=</span> <span class=n>fence</span><span class=o>,</span> <span class=n>i</span> <span class=o>=</span> <span class=n>cursor</span><span class=o>;</span>
        <span class=c1>// 调用foreachremaining方法后不能在调用next方法
</span><span class=c1></span>        <span class=n>cursor</span> <span class=o>=</span> <span class=n>f</span><span class=o>;</span>
        <span class=c1>// 从当前位置cursor开始遍历直到fence即tail为止
</span><span class=c1></span>        <span class=k>while</span> <span class=o>(</span><span class=n>i</span> <span class=o>!=</span> <span class=n>f</span><span class=o>)</span> <span class=o>{</span>
            <span class=nd>@SuppressWarnings</span><span class=o>(</span><span class=s>&#34;unchecked&#34;</span><span class=o>)</span> <span class=n>E</span> <span class=n>e</span> <span class=o>=</span> <span class=o>(</span><span class=n>E</span><span class=o>)</span><span class=n>a</span><span class=o>[</span><span class=n>i</span><span class=o>];</span>
            <span class=n>i</span> <span class=o>=</span> <span class=o>(</span><span class=n>i</span> <span class=o>+</span> <span class=n>1</span><span class=o>)</span> <span class=o>&amp;</span> <span class=n>m</span><span class=o>;</span>
            <span class=k>if</span> <span class=o>(</span><span class=n>e</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
                <span class=k>throw</span> <span class=k>new</span> <span class=n>ConcurrentModificationException</span><span class=o>();</span>
            <span class=n>action</span><span class=o>.</span><span class=na>accept</span><span class=o>(</span><span class=n>e</span><span class=o>);</span>
        <span class=o>}</span>
    <span class=o>}</span>
<span class=o>}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id=坑>坑</h4>
<p>这里要说一个坑
<a test="isHyperLink=false" href=#delete%e6%ba%90%e7%a0%81>delete</a>，由于方法<code>private boolean delete(int i)</code>返回一个boolean值，最初没有在意，以为表示是否删除成功，当我写看到注释<code>This method is called delete rather than remove to emphasize that its semantics differ from those of List.remove(int)</code>.什么叫强调与List.remove()不同，然后就忘记了这回事，等我写完循环数组的删除时，没什么感觉，脑壳昏，没有注意到<code>front&lt;back</code>是返回false。</p>
<p>然后在看迭代器时发现在remove()中<code>if(delete(lastRet))</code>，还能删除失败吗，回去看了一眼，卧槽，<code>front&lt;back</code>居然返回false，但是不对啊，指定元素都已经被覆盖了，删除成功了啊，再回去看一下原来是表示右移，卧了个槽，还好还好，要是我当时看到返回false，我估计直接崩溃，为什么要返回false。。。</p>
<p>
<a test="isHyperLink=false" href=#delete%e6%ba%90%e7%a0%81>delete</a>的注释中可能是想说，这个方法语义和remove不同，即执行delete操作而已。</p>
<h3 id=转换数组toarray>转换数组toArray()</h3>
<p>toArray()无参方法与其余实现一样，底层数组为<code>Object[]</code>，无法转换为原来的类型，应该尽量使用<code>toArray(T[])</code>，并且指定数组的大小推荐为deque.size()</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=nd>@SuppressWarnings</span><span class=o>(</span><span class=s>&#34;unchecked&#34;</span><span class=o>)</span>
<span class=kd>public</span> <span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>T</span><span class=o>[]</span> <span class=nf>toArray</span><span class=o>(</span><span class=n>T</span><span class=o>[]</span> <span class=n>a</span><span class=o>)</span> <span class=o>{</span>
    <span class=kt>int</span> <span class=n>size</span> <span class=o>=</span> <span class=n>size</span><span class=o>();</span>
    <span class=c1>// 指定数组长度小于deque元素个数  创建长度为size的新数组
</span><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>a</span><span class=o>.</span><span class=na>length</span> <span class=o>&lt;</span> <span class=n>size</span><span class=o>)</span>
        <span class=n>a</span> <span class=o>=</span> <span class=o>(</span><span class=n>T</span><span class=o>[])</span><span class=n>java</span><span class=o>.</span><span class=na>lang</span><span class=o>.</span><span class=na>reflect</span><span class=o>.</span><span class=na>Array</span><span class=o>.</span><span class=na>newInstance</span><span class=o>(</span>
                <span class=n>a</span><span class=o>.</span><span class=na>getClass</span><span class=o>().</span><span class=na>getComponentType</span><span class=o>(),</span> <span class=n>size</span><span class=o>);</span>
    <span class=n>copyElements</span><span class=o>(</span><span class=n>a</span><span class=o>);</span>
    <span class=c1>// 指定数组长度过大，将a[size]置为null 后面的位置不影响
</span><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>a</span><span class=o>.</span><span class=na>length</span> <span class=o>&gt;</span> <span class=n>size</span><span class=o>)</span>
        <span class=n>a</span><span class=o>[</span><span class=n>size</span><span class=o>]</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
    <span class=k>return</span> <span class=n>a</span><span class=o>;</span>
<span class=o>}</span>

<span class=cm>/**
</span><span class=cm> * Copies the elements from our element array into the specified array,
</span><span class=cm> * in order (from first to last element in the deque).  It is assumed
</span><span class=cm> * that the array is large enough to hold all elements in the deque.
</span><span class=cm> *
</span><span class=cm> * @return its argument
</span><span class=cm> */</span>
<span class=c1>// 复制elements数组到指定数组。需要指定数组长度至少为deque的元素个数
</span><span class=c1></span><span class=kd>private</span> <span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>T</span><span class=o>[]</span> <span class=nf>copyElements</span><span class=o>(</span><span class=n>T</span><span class=o>[]</span> <span class=n>a</span><span class=o>)</span> <span class=o>{</span>
    <span class=c1>// 即删除head或tail到数组另一端
</span><span class=c1></span>    <span class=c1>// 如果循环数组是连续的一段head在tail前:[0--head--tail--e.length-1]
</span><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>head</span> <span class=o>&lt;</span> <span class=n>tail</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>System</span><span class=o>.</span><span class=na>arraycopy</span><span class=o>(</span><span class=n>elements</span><span class=o>,</span> <span class=n>head</span><span class=o>,</span> <span class=n>a</span><span class=o>,</span> <span class=n>0</span><span class=o>,</span> <span class=n>size</span><span class=o>());</span>
    <span class=o>}</span>
    <span class=c1>// 循环数组不是连续的一段，tail在head前面:[0--tail--head--e.length-1]
</span><span class=c1></span>    <span class=k>else</span> <span class=k>if</span> <span class=o>(</span><span class=n>head</span> <span class=o>&gt;</span> <span class=n>tail</span><span class=o>)</span> <span class=o>{</span>
        <span class=c1>// head到数组末端的长度
</span><span class=c1></span>        <span class=kt>int</span> <span class=n>headPortionLen</span> <span class=o>=</span> <span class=n>elements</span><span class=o>.</span><span class=na>length</span> <span class=o>-</span> <span class=n>head</span><span class=o>;</span>
        <span class=c1>// 先复制head右边的元素head--length-1到数组a从0-headPortionLen-1
</span><span class=c1></span>        <span class=n>System</span><span class=o>.</span><span class=na>arraycopy</span><span class=o>(</span><span class=n>elements</span><span class=o>,</span> <span class=n>head</span><span class=o>,</span> <span class=n>a</span><span class=o>,</span> <span class=n>0</span><span class=o>,</span> <span class=n>headPortionLen</span><span class=o>);</span>
        <span class=c1>// 再复制tail左边的元素从elements的0--tail
</span><span class=c1></span>        <span class=n>System</span><span class=o>.</span><span class=na>arraycopy</span><span class=o>(</span><span class=n>elements</span><span class=o>,</span> <span class=n>0</span><span class=o>,</span> <span class=n>a</span><span class=o>,</span> <span class=n>headPortionLen</span><span class=o>,</span> <span class=n>tail</span><span class=o>);</span>
    <span class=o>}</span>
    <span class=k>return</span> <span class=n>a</span><span class=o>;</span>
<span class=o>}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id=参考>参考</h2>
<ul>
<li>
<a test="isHyperLink=false" href=ArrayDeque.java>基于jdk8 ArrayDeque源码</a></li>
<li>
<a test="isHyperLink=true" href=https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/4-Stack%20and%20Queue.md title="Stack and Queue">https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/4-Stack%20and%20Queue.md</a></li>
</ul>
</div>
</article>
</div>
<script src=https://utteranc.es/client.js repo=navyd/navyd.github.io issue-term=pathname theme=github-light crossorigin=anonymous async></script>
<noscript>Please enable JavaScript to view the <a href=https://github.com/utterance>comments powered by utterances.</a></noscript>
</div>
</main>
<footer id=footer class=footer>
<div class=social-links>
<a href=https://github.com/NavyD/navyd.github.io class="iconfont icon-github" title=github></a>
<a href=https://navyd.github.io/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a>
</div>
<div class=copyright>
<span class=power-by>
由 <a class=hexo-link href=https://gohugo.io>Hugo</a> 强力驱动
</span>
<span class=division>|</span>
<span class=theme-info>
主题 -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a>
</span>
<div class=busuanzi-footer>
<span id=busuanzi_container_site_pv> 本站总访问量 <span id=busuanzi_value_site_pv><img src=/img/spinner.svg alt=spinner.svg></span> 次 </span>
<span class=division>|</span>
<span id=busuanzi_container_site_uv> 本站总访客数 <span id=busuanzi_value_site_uv><img src=/img/spinner.svg alt=spinner.svg></span> 人 </span>
</div>
<span class=copyright-year>
&copy;
2021<span class=heart><i class="iconfont icon-heart"></i></span><span>navyd</span>
</span>
</div>
</footer>
<div class=back-to-top id=back-to-top>
<i class="iconfont icon-up"></i>
</div>
</div>
<script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/timeago.js@3.0.2/dist/timeago.min.js integrity="sha256-jwCP0NAdCBloaIWTWHmW4i3snUNMHUNO+jr9rYd2iOI=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/timeago.js@3.0.2/dist/timeago.locales.min.js integrity="sha256-ZwofwC1Lf/faQCzN7nZtfijVV6hSwxjQMwXL4gn9qU8=" crossorigin=anonymous></script>
<script>var languageCode="en".replace(/-/g,'_').replace(/_(.*)/,function(b,a){return b.replace(a,a.toUpperCase())});timeago().render(document.querySelectorAll('.timeago'),languageCode),timeago.cancel()</script>
<script type=text/javascript src=/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js></script>
</body>
</html>